{
  "module": {
    "title": "Collections Framework",
    "description": "Master Java Collections Framework including Lists, Sets, Maps, and utility classes",
    "lessons": [
      {
        "id": "java-3-1",
        "title": "List Interface and Implementations",
        "duration": "60 minutes",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "The List interface represents an ordered collection of elements. ArrayList and LinkedList are the most commonly used implementations."
            },
            {
              "type": "text",
              "content": "The List interface is one of the most fundamental collection types in Java, representing an ordered sequence of elements. Unlike sets, lists allow duplicate elements and maintain insertion order, making them ideal for scenarios where element order matters."
            },
            {
              "type": "text",
              "content": "Key characteristics of List:",
              "subsections": [
                "Ordered Collection: Elements maintain their insertion order",
                "Indexed Access: Elements can be accessed by their position (index)",
                "Duplicate Elements: Lists allow multiple occurrences of the same element",
                "Dynamic Sizing: Lists can grow and shrink as needed",
                "Null Elements: Lists can contain null values"
              ]
            },
            {
              "type": "text",
              "content": "Common List implementations:",
              "subsections": [
                "ArrayList: Resizable array implementation with fast random access",
                "LinkedList: Doubly-linked list implementation with fast insertions/deletions",
                "Vector: Thread-safe legacy implementation similar to ArrayList",
                "Stack: LIFO (Last-In-First-Out) implementation extending Vector"
              ]
            },
            {
              "type": "text",
              "content": "When choosing between ArrayList and LinkedList, consider that ArrayList provides O(1) random access but slower insertions/deletions, while LinkedList provides fast insertions/deletions but slower random access."
            },
            {
              "type": "code",
              "language": "java",
              "content": "import java.util.*;\n\npublic class ListDemo {\n    public static void main(String[] args) {\n        // ArrayList\n        List<String> arrayList = new ArrayList<>();\n        arrayList.add(\"Apple\");\n        arrayList.add(\"Banana\");\n        arrayList.add(1, \"Mango\");\n        \n        System.out.println(\"ArrayList: \" + arrayList);\n        \n        // LinkedList\n        List<Integer> linkedList = new LinkedList<>();\n        linkedList.add(10);\n        linkedList.add(20);\n        linkedList.addFirst(5);\n        \n        System.out.println(\"LinkedList: \" + linkedList);\n        \n        // Iterating\n        for (String item : arrayList) {\n            System.out.println(item);\n        }\n        \n        // Basic operations\n        arrayList.set(1, \"Orange\");\n        arrayList.remove(2);\n        System.out.println(\"After operations: \" + arrayList);\n    }\n}"
            },
            {
              "type": "text",
              "content": "ArrayList provides fast random access but slower insertions/deletions. LinkedList provides fast insertions/deletions but slower random access. Choose based on your primary operations."
            }
          ]
        }
      },
      {
        "id": "java-3-2",
        "title": "Set Interface and Implementations",
        "duration": "45 minutes",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "The Set interface represents a collection that contains no duplicate elements. HashSet, LinkedHashSet, and TreeSet are the main implementations."
            },
            {
              "type": "text",
              "content": "The Set interface represents a collection that contains no duplicate elements, making it perfect for scenarios where you need to maintain a unique collection of items. Sets are commonly used for removing duplicates, checking membership, and mathematical set operations."
            },
            {
              "type": "text",
              "content": "Key characteristics of Set:",
              "subsections": [
                "No Duplicates: Each element can appear only once in the set",
                "Unordered (HashSet): Elements have no guaranteed order",
                "Ordered (LinkedHashSet): Elements maintain insertion order",
                "Sorted (TreeSet): Elements are automatically sorted",
                "Null Elements: Most sets allow one null element"
              ]
            },
            {
              "type": "text",
              "content": "Common Set implementations:",
              "subsections": [
                "HashSet: Fastest implementation with no ordering guarantee",
                "LinkedHashSet: Maintains insertion order with HashSet performance",
                "TreeSet: Sorted implementation with O(log n) operations",
                "EnumSet: Specialized set for enum types with excellent performance"
              ]
            },
            {
              "type": "text",
              "content": "Set operations include union, intersection, and difference, which can be performed using methods like addAll(), retainAll(), and removeAll(). Sets are essential for algorithms that require unique element collections."
            },
            {
              "type": "code",
              "language": "java",
              "content": "import java.util.*;\n\npublic class SetDemo {\n    public static void main(String[] args) {\n        // HashSet - no duplicates\n        Set<String> hashSet = new HashSet<>();\n        hashSet.add(\"Apple\");\n        hashSet.add(\"Banana\");\n        hashSet.add(\"Apple\"); // Duplicate, won't be added\n        \n        System.out.println(\"HashSet: \" + hashSet);\n        \n        // TreeSet - sorted order\n        Set<Integer> treeSet = new TreeSet<>();\n        treeSet.add(5);\n        treeSet.add(2);\n        treeSet.add(8);\n        \n        System.out.println(\"TreeSet: \" + treeSet);\n        \n        // Set operations\n        Set<String> set1 = new HashSet<>(Arrays.asList(\"A\", \"B\", \"C\"));\n        Set<String> set2 = new HashSet<>(Arrays.asList(\"C\", \"D\", \"E\"));\n        \n        // Union\n        Set<String> union = new HashSet<>(set1);\n        union.addAll(set2);\n        System.out.println(\"Union: \" + union);\n        \n        // Intersection\n        Set<String> intersection = new HashSet<>(set1);\n        intersection.retainAll(set2);\n        System.out.println(\"Intersection: \" + intersection);\n    }\n}"
            },
            {
              "type": "text",
              "content": "HashSet provides O(1) average time complexity for add/remove/contains. TreeSet provides sorted order but O(log n) time complexity. LinkedHashSet maintains insertion order with HashSet performance."
            }
          ]
        }
      },
      {
        "id": "java-3-3",
        "title": "Map Interface and Implementations",
        "duration": "60 minutes",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "The Map interface represents a key-value pair collection. HashMap, LinkedHashMap, and TreeMap are the main implementations."
            },
            {
              "type": "text",
              "content": "The Map interface represents a collection of key-value pairs, where each key maps to exactly one value. Maps are essential for scenarios where you need to associate data with unique identifiers, such as user profiles, configuration settings, or database records."
            },
            {
              "type": "text",
              "content": "Key characteristics of Map:",
              "subsections": [
                "Key-Value Pairs: Each entry consists of a key and its associated value",
                "Unique Keys: No two entries can have the same key",
                "Fast Lookup: O(1) average time complexity for get/put operations (HashMap)",
                "Null Support: Most maps allow one null key and multiple null values",
                "Dynamic Sizing: Maps can grow and shrink as needed"
              ]
            },
            {
              "type": "text",
              "content": "Common Map implementations:",
              "subsections": [
                "HashMap: Fastest implementation with no ordering guarantee",
                "LinkedHashMap: Maintains insertion order with HashMap performance",
                "TreeMap: Sorted implementation with keys in natural order",
                "Hashtable: Thread-safe legacy implementation",
                "ConcurrentHashMap: Thread-safe implementation for concurrent access"
              ]
            },
            {
              "type": "text",
              "content": "Maps are widely used in real-world applications for caching, configuration management, database operations, and any scenario requiring efficient key-based data retrieval."
            },
            {
              "type": "code",
              "language": "java",
              "content": "import java.util.*;\n\npublic class MapDemo {\n    public static void main(String[] args) {\n        // HashMap\n        Map<String, Integer> hashMap = new HashMap<>();\n        hashMap.put(\"Apple\", 5);\n        hashMap.put(\"Banana\", 3);\n        hashMap.put(\"Apple\", 6); // Overwrites\n        \n        System.out.println(\"HashMap: \" + hashMap);\n        System.out.println(\"Apple count: \" + hashMap.get(\"Apple\"));\n        \n        // TreeMap - sorted\n        Map<String, Double> treeMap = new TreeMap<>();\n        treeMap.put(\"Zebra\", 100.0);\n        treeMap.put(\"Apple\", 50.0);\n        \n        System.out.println(\"TreeMap: \" + treeMap);\n        \n        // Iterating\n        for (Map.Entry<String, Integer> entry : hashMap.entrySet()) {\n            System.out.println(entry.getKey() + \": \" + entry.getValue());\n        }\n    }\n}"
            },
            {
              "type": "text",
              "content": "HashMap provides O(1) average time complexity for get/put operations. TreeMap provides sorted keys but O(log n) time complexity. LinkedHashMap maintains insertion order with HashMap performance."
            }
          ]
        }
      },
      {
        "id": "java-3-4",
        "title": "Queue and Deque",
        "duration": "45 minutes",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Queue represents a collection designed for holding elements prior to processing. Deque extends Queue to allow insertion and removal at both ends."
            },
            {
              "type": "text",
              "content": "Queue and Deque interfaces represent collections designed for holding elements prior to processing. They are fundamental data structures used in various algorithms and real-world applications like task scheduling, breadth-first search, and producer-consumer patterns."
            },
            {
              "type": "text",
              "content": "Key characteristics of Queue:",
              "subsections": [
                "FIFO (First-In-First-Out): Elements are processed in the order they were added",
                "Blocking Operations: Some implementations provide blocking methods for thread safety",
                "Priority Queues: Elements can be ordered by priority rather than insertion order",
                "Bounded Queues: Some implementations have fixed capacity",
                "Thread Safety: Concurrent implementations are available for multi-threaded applications"
              ]
            },
            {
              "type": "text",
              "content": "Common Queue implementations:",
              "subsections": [
                "LinkedList: General-purpose queue implementation",
                "PriorityQueue: Orders elements by natural ordering or custom comparator",
                "ArrayBlockingQueue: Thread-safe bounded queue backed by an array",
                "LinkedBlockingQueue: Thread-safe unbounded queue backed by linked nodes",
                "ConcurrentLinkedQueue: Thread-safe unbounded queue for high concurrency"
              ]
            },
            {
              "type": "text",
              "content": "Deque (Double-Ended Queue) extends Queue functionality by allowing insertion and removal at both ends, making it suitable for implementing both stacks and queues efficiently."
            },
            {
              "type": "code",
              "language": "java",
              "content": "import java.util.*;\n\npublic class QueueDequeDemo {\n    public static void main(String[] args) {\n        // PriorityQueue - elements ordered by priority\n        Queue<Integer> priorityQueue = new PriorityQueue<>();\n        priorityQueue.offer(5);\n        priorityQueue.offer(2);\n        priorityQueue.offer(8);\n        priorityQueue.offer(1);\n        priorityQueue.offer(3);\n        \n        System.out.println(\"PriorityQueue: \" + priorityQueue);\n        System.out.println(\"Peek: \" + priorityQueue.peek());\n        \n        System.out.println(\"\\nRemoving elements:\");\n        while (!priorityQueue.isEmpty()) {\n            System.out.print(priorityQueue.poll() + \" \");\n        }\n        System.out.println();\n        \n        // Custom comparator for PriorityQueue\n        Queue<String> stringPriorityQueue = new PriorityQueue<>((a, b) -> b.compareTo(a));\n        stringPriorityQueue.offer(\"Apple\");\n        stringPriorityQueue.offer(\"Banana\");\n        stringPriorityQueue.offer(\"Orange\");\n        \n        System.out.println(\"\\nString PriorityQueue (reverse order): \" + stringPriorityQueue);\n        \n        // LinkedList as Queue\n        Queue<String> linkedListQueue = new LinkedList<>();\n        linkedListQueue.offer(\"First\");\n        linkedListQueue.offer(\"Second\");\n        linkedListQueue.offer(\"Third\");\n        \n        System.out.println(\"\\nLinkedList Queue: \" + linkedListQueue);\n        System.out.println(\"Peek: \" + linkedListQueue.peek());\n        System.out.println(\"Poll: \" + linkedListQueue.poll());\n        System.out.println(\"After poll: \" + linkedListQueue);\n        \n        // Deque (Double-ended queue)\n        Deque<String> deque = new LinkedList<>();\n        \n        // Adding elements\n        deque.addFirst(\"First\");\n        deque.addLast(\"Last\");\n        deque.offerFirst(\"NewFirst\");\n        deque.offerLast(\"NewLast\");\n        \n        System.out.println(\"\\nDeque: \" + deque);\n        \n        // Accessing elements\n        System.out.println(\"First element: \" + deque.getFirst());\n        System.out.println(\"Last element: \" + deque.getLast());\n        System.out.println(\"Peek first: \" + deque.peekFirst());\n        System.out.println(\"Peek last: \" + deque.peekLast());\n        \n        // Removing elements\n        System.out.println(\"Remove first: \" + deque.removeFirst());\n        System.out.println(\"Remove last: \" + deque.removeLast());\n        System.out.println(\"After removals: \" + deque);\n        \n        // ArrayDeque - more efficient than LinkedList for Deque operations\n        Deque<Integer> arrayDeque = new ArrayDeque<>();\n        arrayDeque.addFirst(1);\n        arrayDeque.addLast(2);\n        arrayDeque.addFirst(0);\n        arrayDeque.addLast(3);\n        \n        System.out.println(\"\\nArrayDeque: \" + arrayDeque);\n        \n        // Stack operations using Deque\n        Deque<String> stack = new ArrayDeque<>();\n        stack.push(\"First\");\n        stack.push(\"Second\");\n        stack.push(\"Third\");\n        \n        System.out.println(\"\\nStack: \" + stack);\n        System.out.println(\"Pop: \" + stack.pop());\n        System.out.println(\"Peek: \" + stack.peek());\n        \n        // Queue simulation with Deque\n        Deque<String> queue = new ArrayDeque<>();\n        queue.offer(\"Task1\");\n        queue.offer(\"Task2\");\n        queue.offer(\"Task3\");\n        \n        System.out.println(\"\\nQueue: \" + queue);\n        System.out.println(\"Process: \" + queue.poll());\n        System.out.println(\"Next: \" + queue.peek());\n        \n        // PriorityQueue with custom objects\n        Queue<Task> taskQueue = new PriorityQueue<>((t1, t2) -> {\n            if (t1.getPriority() != t2.getPriority()) {\n                return Integer.compare(t2.getPriority(), t1.getPriority()); // Higher priority first\n            }\n            return t1.getName().compareTo(t2.getName());\n        });\n        \n        taskQueue.offer(new Task(\"Low Priority Task\", 1));\n        taskQueue.offer(new Task(\"High Priority Task\", 5));\n        taskQueue.offer(new Task(\"Medium Priority Task\", 3));\n        taskQueue.offer(new Task(\"Another High Priority\", 5));\n        \n        System.out.println(\"\\nTask Queue:\");\n        while (!taskQueue.isEmpty()) {\n            Task task = taskQueue.poll();\n            System.out.println(\"Processing: \" + task.getName() + \" (Priority: \" + task.getPriority() + \")\");\n        }\n    }\n}\n\n// Task class for PriorityQueue demonstration\nclass Task {\n    private String name;\n    private int priority;\n    \n    public Task(String name, int priority) {\n        this.name = name;\n        this.priority = priority;\n    }\n    \n    public String getName() { return name; }\n    public int getPriority() { return priority; }\n    \n    @Override\n    public String toString() {\n        return \"Task{name='\" + name + \"', priority=\" + priority + '}';\n    }\n}"
            },
            {
              "type": "text",
              "content": "PriorityQueue orders elements by natural ordering or custom comparator. Deque provides double-ended queue operations. ArrayDeque is more efficient than LinkedList for Deque operations."
            }
          ]
        }
      }
    ],
    "quiz": {
      "questions": [
        {
          "question": "Which List implementation provides the best performance for random access?",
          "options": [
            "LinkedList",
            "ArrayList",
            "Vector",
            "Stack"
          ],
          "correct": 1,
          "explanation": "ArrayList provides O(1) random access time complexity, making it the best choice for frequent random access operations."
        },
        {
          "question": "What is the main difference between HashSet and TreeSet?",
          "options": [
            "HashSet allows duplicates, TreeSet doesn't",
            "HashSet is unordered, TreeSet maintains sorted order",
            "HashSet is thread-safe, TreeSet is not",
            "HashSet is faster, TreeSet is slower"
          ],
          "correct": 1,
          "explanation": "HashSet provides no guarantee about the order of elements, while TreeSet maintains elements in sorted order."
        },
        {
          "question": "Which Map implementation maintains insertion order?",
          "options": [
            "HashMap",
            "TreeMap",
            "LinkedHashMap",
            "Hashtable"
          ],
          "correct": 2,
          "explanation": "LinkedHashMap maintains the insertion order of elements, unlike HashMap which provides no ordering guarantee."
        },
        {
          "question": "What is the time complexity of HashMap's get and put operations?",
          "options": [
            "O(n)",
            "O(log n)",
            "O(1)",
            "O(nÂ²)"
          ],
          "correct": 2,
          "explanation": "HashMap provides O(1) average time complexity for get and put operations, making it very efficient for most use cases."
        },
        {
          "question": "Which collection is best for implementing a stack?",
          "options": [
            "ArrayList",
            "LinkedList",
            "ArrayDeque",
            "PriorityQueue"
          ],
          "correct": 2,
          "explanation": "ArrayDeque is the recommended choice for implementing a stack as it provides efficient push and pop operations."
        }
      ]
    }
  }
} 