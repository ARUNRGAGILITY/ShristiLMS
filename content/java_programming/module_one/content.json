{
  "module": {
    "title": "Introduction to Java",
    "description": "Learn the fundamentals of Java programming, object-oriented concepts, and basic syntax",
    "lessons": [
      {
        "id": "java-1-1",
        "title": "What is Java?",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Java is a high-level, object-oriented programming language developed by Sun Microsystems (now Oracle) in 1995. It's designed to be platform-independent, meaning Java programs can run on any device that has a Java Virtual Machine (JVM)."
            },
            {
              "type": "text",
              "content": "Key features of Java:",
              "subsections": [
                "Platform independent - Write once, run anywhere",
                "Object-oriented programming language",
                "Strongly typed with static type checking",
                "Automatic memory management (garbage collection)",
                "Rich standard library and ecosystem",
                "Secure and robust"
              ]
            },
            {
              "type": "code",
              "language": "java",
              "content": "// Simple Java program\npublic class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, World!\");\n    }\n}"
            }
          ]
        }
      },
      {
        "id": "java-1-2",
        "title": "Setting Up Java Development Environment",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "To start programming in Java, you need to set up the Java Development Kit (JDK) and an Integrated Development Environment (IDE)."
            },
            {
              "type": "text",
              "content": "Setup steps:",
              "subsections": [
                "Download and install JDK (Java Development Kit)",
                "Set up JAVA_HOME environment variable",
                "Install an IDE (Eclipse, IntelliJ IDEA, or VS Code)",
                "Verify installation with command line tools"
              ]
            },
            {
              "type": "code",
              "language": "bash",
              "content": "# Check Java version\njava -version\njavac -version\n\n# Set JAVA_HOME (Windows)\nset JAVA_HOME=C:\\Program Files\\Java\\jdk-17\n\n# Set JAVA_HOME (macOS/Linux)\nexport JAVA_HOME=/usr/lib/jvm/java-17-openjdk\n\n# Add Java to PATH\n# Windows: %JAVA_HOME%\\bin\n# macOS/Linux: $JAVA_HOME/bin"
            },
            {
              "type": "code",
              "language": "java",
              "content": "// First Java program\npublic class FirstProgram {\n    public static void main(String[] args) {\n        System.out.println(\"Welcome to Java Programming!\");\n        \n        // Print Java version\n        System.out.println(\"Java Version: \" + System.getProperty(\"java.version\"));\n    }\n}"
            }
          ]
        }
      },
      {
        "id": "java-1-3",
        "title": "Basic Syntax and Data Types",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Java is a strongly-typed language, meaning every variable must have a declared type. Understanding the basic syntax and data types is fundamental to Java programming."
            },
            {
              "type": "text",
              "content": "Java's type system is designed to catch errors at compile time rather than runtime, making programs more reliable and efficient. Every variable, parameter, and return value must have a specific type declared, which helps prevent type-related bugs and improves code readability."
            },
            {
              "type": "text",
              "content": "Java data types are categorized into two main groups:",
              "subsections": [
                "Primitive Types: Basic data types stored directly in memory (byte, short, int, long, float, double, char, boolean)",
                "Reference Types: Complex types that store references to objects (classes, interfaces, arrays, enums)"
              ]
            },
            {
              "type": "text",
              "content": "Key characteristics of Java's type system:",
              "subsections": [
                "Static Typing: Types are checked at compile time",
                "Type Safety: Prevents incompatible type assignments",
                "Memory Efficiency: Primitive types use minimal memory",
                "Object-Oriented: Reference types support inheritance and polymorphism",
                "Automatic Boxing: Automatic conversion between primitives and wrapper classes"
              ]
            },
            {
              "type": "text",
              "content": "Understanding data types is crucial for memory management, performance optimization, and writing maintainable code. Choosing the right data type can significantly impact your program's efficiency and correctness."
            },
            {
              "type": "code",
              "language": "java",
              "content": "public class DataTypes {\n    public static void main(String[] args) {\n        // Primitive data types\n        byte byteValue = 127; // 8-bit signed integer\n        short shortValue = 32767; // 16-bit signed integer\n        int intValue = 2147483647; // 32-bit signed integer\n        long longValue = 9223372036854775807L; // 64-bit signed integer\n        \n        float floatValue = 3.14f; // 32-bit floating point\n        double doubleValue = 3.14159265359; // 64-bit floating point\n        \n        char charValue = 'A'; // 16-bit Unicode character\n        boolean booleanValue = true; // true or false\n        \n        // Reference data types\n        String stringValue = \"Hello, Java!\";\n        Integer integerObject = 100;\n        Double doubleObject = 3.14;\n        \n        // Arrays\n        int[] numbers = {1, 2, 3, 4, 5};\n        String[] names = {\"Alice\", \"Bob\", \"Charlie\"};\n        \n        // Printing values\n        System.out.println(\"Byte: \" + byteValue);\n        System.out.println(\"Short: \" + shortValue);\n        System.out.println(\"Int: \" + intValue);\n        System.out.println(\"Long: \" + longValue);\n        System.out.println(\"Float: \" + floatValue);\n        System.out.println(\"Double: \" + doubleValue);\n        System.out.println(\"Char: \" + charValue);\n        System.out.println(\"Boolean: \" + booleanValue);\n        System.out.println(\"String: \" + stringValue);\n        \n        // Type conversion (casting)\n        int intFromDouble = (int) doubleValue;\n        double doubleFromInt = intValue;\n        \n        System.out.println(\"Int from double: \" + intFromDouble);\n        System.out.println(\"Double from int: \" + doubleFromInt);\n    }\n}"
            },
            {
              "type": "text",
              "content": "Java has two categories of data types: primitive types (stored directly in memory) and reference types (stored as references to objects). Understanding the difference is crucial for memory management and performance."
            },
            {
              "type": "text",
              "content": "Primitive data types are the building blocks of Java programming. They represent simple values and are stored directly in memory, making them very efficient for basic operations. Each primitive type has a specific size and range of values it can hold."
            },
            {
              "type": "text",
              "content": "Integer primitive types (in order of size):",
              "subsections": [
                "byte: 8-bit signed integer (-128 to 127), used for small numbers to save memory",
                "short: 16-bit signed integer (-32,768 to 32,767), used for medium-sized numbers",
                "int: 32-bit signed integer (-2^31 to 2^31-1), most commonly used integer type",
                "long: 64-bit signed integer (-2^63 to 2^63-1), used for very large numbers"
              ]
            },
            {
              "type": "text",
              "content": "Floating-point primitive types:",
              "subsections": [
                "float: 32-bit floating point, 6-7 decimal digits precision, suffix 'f' required",
                "double: 64-bit floating point, 15-16 decimal digits precision, default for decimals"
              ]
            },
            {
              "type": "text",
              "content": "Other primitive types:",
              "subsections": [
                "char: 16-bit Unicode character, represents a single character",
                "boolean: true or false value, used for logical operations and conditions"
              ]
            },
            {
              "type": "text",
              "content": "Reference types include arrays, classes, interfaces, and enums. They are stored as references (memory addresses) pointing to objects in the heap. Arrays are special reference types that can hold multiple values of the same type."
            },
            {
              "type": "text",
              "content": "Type conversion (casting) is necessary when assigning values between different types. Implicit conversion happens when no data loss occurs, while explicit casting is required when there's potential for data loss."
            },
            {
              "type": "text",
              "content": "Wrapper classes (Integer, Double, Boolean, etc.) provide object representations of primitive types. They are useful when you need to store primitives in collections or when working with generics."
            },
            {
              "type": "text",
              "content": "Memory considerations: Primitive types are stored on the stack and are very memory-efficient, while reference types are stored on the heap and require more memory due to object overhead."
            }
          ]
        }
      },
      {
        "id": "java-1-4",
        "title": "Variables and Operators",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Variables in Java must be declared with a specific type and can be initialized with values. Java provides various operators for performing operations on variables and values."
            },
            {
              "type": "text",
              "content": "Variables are fundamental building blocks in Java programming that allow you to store and manipulate data. They serve as named containers for values that can change during program execution. Understanding variables and operators is essential for writing effective Java programs."
            },
            {
              "type": "text",
              "content": "Variable declaration and initialization:",
              "subsections": [
                "Declaration: Specifying the variable type and name (e.g., int age;)",
                "Initialization: Assigning an initial value to the variable (e.g., int age = 25;)",
                "Declaration and Initialization: Combining both in one statement",
                "Constants: Using final keyword to create immutable variables",
                "Scope: Understanding where variables can be accessed"
              ]
            },
            {
              "type": "text",
              "content": "Variable naming conventions in Java:",
              "subsections": [
                "Camel Case: Use camelCase for variable names (e.g., firstName, totalAmount)",
                "Descriptive Names: Choose names that clearly indicate the variable's purpose",
                "Avoid Keywords: Don't use Java reserved words as variable names",
                "Start with Letter: Variable names must start with a letter, underscore, or dollar sign",
                "Case Sensitive: Java is case-sensitive, so age and Age are different variables"
              ]
            },
            {
              "type": "text",
              "content": "Java operators are symbols that perform operations on operands (variables, literals, or expressions). They are categorized into different types based on their functionality and the number of operands they work with."
            },
            {
              "type": "code",
              "language": "java",
              "content": "public class VariablesAndOperators {\n    public static void main(String[] args) {\n        // Variable declaration and initialization\n        int age = 25;\n        String name = \"John Doe\";\n        double salary = 50000.0;\n        \n        // Constants (final keyword)\n        final double PI = 3.14159;\n        final String COMPANY_NAME = \"TechCorp\";\n        \n        // Arithmetic operators\n        int a = 10;\n        int b = 3;\n        \n        System.out.println(\"Addition: \" + (a + b)); // 13\n        System.out.println(\"Subtraction: \" + (a - b)); // 7\n        System.out.println(\"Multiplication: \" + (a * b)); // 30\n        System.out.println(\"Division: \" + (a / b)); // 3\n        System.out.println(\"Modulus: \" + (a % b)); // 1\n        \n        // Increment and decrement\n        int count = 5;\n        System.out.println(\"Original count: \" + count);\n        System.out.println(\"Post-increment: \" + count++); // 5\n        System.out.println(\"After post-increment: \" + count); // 6\n        System.out.println(\"Pre-increment: \" + ++count); // 7\n        \n        // Assignment operators\n        int x = 10;\n        x += 5; // Same as x = x + 5\n        x -= 3; // Same as x = x - 3\n        x *= 2; // Same as x = x * 2\n        x /= 4; // Same as x = x / 4\n        \n        System.out.println(\"Final x: \" + x);\n        \n        // Comparison operators\n        int num1 = 10;\n        int num2 = 20;\n        \n        System.out.println(\"num1 == num2: \" + (num1 == num2)); // false\n        System.out.println(\"num1 != num2: \" + (num1 != num2)); // true\n        System.out.println(\"num1 < num2: \" + (num1 < num2)); // true\n        System.out.println(\"num1 > num2: \" + (num1 > num2)); // false\n        System.out.println(\"num1 <= num2: \" + (num1 <= num2)); // true\n        System.out.println(\"num1 >= num2: \" + (num1 >= num2)); // false\n        \n        // Logical operators\n        boolean isTrue = true;\n        boolean isFalse = false;\n        \n        System.out.println(\"AND: \" + (isTrue && isFalse)); // false\n        System.out.println(\"OR: \" + (isTrue || isFalse)); // true\n        System.out.println(\"NOT: \" + (!isTrue)); // false\n        \n        // String concatenation\n        String firstName = \"John\";\n        String lastName = \"Doe\";\n        String fullName = firstName + \" \" + lastName;\n        System.out.println(\"Full name: \" + fullName);\n        \n        // String formatting\n        String formatted = String.format(\"Name: %s, Age: %d, Salary: %.2f\", \n                                       name, age, salary);\n        System.out.println(formatted);\n    }\n}"
            },
            {
              "type": "text",
              "content": "Java operators follow precedence rules. Understanding operator precedence helps avoid unexpected results in complex expressions."
            },
            {
              "type": "text",
              "content": "Arithmetic operators perform mathematical operations on numeric values. They include addition (+), subtraction (-), multiplication (*), division (/), and modulus (%). The modulus operator returns the remainder of a division operation and is useful for determining if a number is even or odd."
            },
            {
              "type": "text",
              "content": "Increment and decrement operators (++ and --) are used to increase or decrease a variable's value by 1. They can be used in prefix (++x) or postfix (x++) form. The difference is when the increment/decrement occurs relative to the expression evaluation."
            },
            {
              "type": "text",
              "content": "Assignment operators combine assignment with arithmetic operations. They provide a shorthand way to modify variables. Common assignment operators include +=, -=, *=, /=, and %=. These operators are more efficient than separate arithmetic and assignment operations."
            },
            {
              "type": "text",
              "content": "Comparison operators are used to compare values and return boolean results. They include equality (==), inequality (!=), less than (<), greater than (>), less than or equal (<=), and greater than or equal (>=). These operators are essential for conditional statements and loops."
            },
            {
              "type": "text",
              "content": "Logical operators work with boolean values and are used in conditional expressions. The AND operator (&&) returns true only if both operands are true. The OR operator (||) returns true if at least one operand is true. The NOT operator (!) inverts the boolean value."
            },
            {
              "type": "text",
              "content": "String concatenation uses the + operator to join strings together. Java automatically converts non-string values to strings when concatenating. The String.format() method provides more control over string formatting with placeholders for different data types."
            },
            {
              "type": "text",
              "content": "Operator precedence determines the order in which operations are performed. Understanding precedence is crucial for writing correct expressions. Parentheses can be used to override the default precedence and make expressions more readable."
            },
            {
              "type": "text",
              "content": "Best practices for variables and operators:",
              "subsections": [
                "Use meaningful variable names that clearly indicate their purpose",
                "Initialize variables when declaring them to avoid undefined behavior",
                "Use constants (final) for values that should not change",
                "Be careful with floating-point arithmetic due to precision issues",
                "Use parentheses to clarify complex expressions and avoid precedence confusion",
                "Choose appropriate data types to optimize memory usage and performance"
              ]
            }
          ]
        }
      },
      {
        "id": "java-1-5",
        "title": "Control Flow Statements",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Control flow statements allow you to control the execution of your program based on conditions and loops. These are essential for creating dynamic and responsive applications."
            },
            {
              "type": "text",
              "content": "Control flow statements are the backbone of program logic, enabling you to make decisions and repeat actions based on conditions. They transform static code into dynamic, responsive applications that can adapt to different situations and user inputs."
            },
            {
              "type": "text",
              "content": "Types of control flow statements in Java:",
              "subsections": [
                "Conditional Statements: if, if-else, if-else-if-else for decision making",
                "Switch Statements: Multi-way branching based on a single variable",
                "Loop Statements: for, while, do-while for repetitive execution",
                "Jump Statements: break, continue, return for flow control",
                "Ternary Operator: Shorthand conditional expression"
              ]
            },
            {
              "type": "text",
              "content": "Conditional statements evaluate boolean expressions and execute different code blocks based on the result. They enable programs to respond differently to various conditions, making applications interactive and intelligent."
            },
            {
              "type": "text",
              "content": "Loop statements allow you to execute a block of code multiple times. They are essential for processing collections of data, implementing algorithms, and creating interactive programs. Each loop type has specific use cases and advantages."
            },
            {
              "type": "text",
              "content": "Understanding control flow is crucial for:",
              "subsections": [
                "User Input Processing: Responding to different user choices",
                "Data Validation: Checking input values and data integrity",
                "Algorithm Implementation: Creating complex computational logic",
                "Error Handling: Managing different error conditions",
                "Performance Optimization: Controlling program execution efficiently"
              ]
            },
            {
              "type": "code",
              "language": "java",
              "content": "public class ControlFlow {\n    public static void main(String[] args) {\n        // If statement\n        int age = 18;\n        \n        if (age >= 18) {\n            System.out.println(\"You are an adult\");\n        } else {\n            System.out.println(\"You are a minor\");\n        }\n        \n        // If-else if-else\n        int score = 85;\n        \n        if (score >= 90) {\n            System.out.println(\"Grade: A\");\n        } else if (score >= 80) {\n            System.out.println(\"Grade: B\");\n        } else if (score >= 70) {\n            System.out.println(\"Grade: C\");\n        } else {\n            System.out.println(\"Grade: F\");\n        }\n        \n        // Switch statement\n        int day = 1;\n        String dayName;\n        \n        switch (day) {\n            case 1:\n                dayName = \"Monday\";\n                break;\n            case 2:\n                dayName = \"Tuesday\";\n                break;\n            case 3:\n                dayName = \"Wednesday\";\n                break;\n            case 4:\n                dayName = \"Thursday\";\n                break;\n            case 5:\n                dayName = \"Friday\";\n                break;\n            case 6:\n            case 7:\n                dayName = \"Weekend\";\n                break;\n            default:\n                dayName = \"Invalid day\";\n        }\n        \n        System.out.println(\"Day: \" + dayName);\n        \n        // Ternary operator\n        String status = (age >= 18) ? \"Adult\" : \"Minor\";\n        System.out.println(\"Status: \" + status);\n        \n        // For loop\n        System.out.println(\"\\nFor loop:\");\n        for (int i = 0; i < 5; i++) {\n            System.out.println(\"Iteration \" + i);\n        }\n        \n        // While loop\n        System.out.println(\"\\nWhile loop:\");\n        int count = 0;\n        while (count < 3) {\n            System.out.println(\"Count: \" + count);\n            count++;\n        }\n        \n        // Do-while loop\n        System.out.println(\"\\nDo-while loop:\");\n        int num = 0;\n        do {\n            System.out.println(\"Number: \" + num);\n            num++;\n        } while (num < 3);\n        \n        // Enhanced for loop (for arrays)\n        System.out.println(\"\\nEnhanced for loop:\");\n        String[] colors = {\"Red\", \"Green\", \"Blue\"};\n        for (String color : colors) {\n            System.out.println(\"Color: \" + color);\n        }\n        \n        // Break and continue\n        System.out.println(\"\\nBreak and continue:\");\n        for (int i = 0; i < 10; i++) {\n            if (i == 5) {\n                break; // Exit the loop\n            }\n            if (i == 2) {\n                continue; // Skip this iteration\n            }\n            System.out.println(\"i = \" + i);\n        }\n    }\n}"
            },
            {
              "type": "text",
              "content": "Control flow statements are fundamental to programming logic. Understanding when to use each type of statement helps create efficient and readable code."
            },
            {
              "type": "text",
              "content": "If statements are the most basic form of conditional execution. They evaluate a boolean expression and execute the code block only if the condition is true. The if-else structure provides an alternative path when the condition is false."
            },
            {
              "type": "text",
              "content": "If-else-if-else chains allow for multiple conditions to be evaluated in sequence. Each condition is checked only if all previous conditions were false. This structure is useful for handling multiple mutually exclusive scenarios."
            },
            {
              "type": "text",
              "content": "Switch statements provide an efficient way to handle multiple possible values of a single variable. They are more readable than long if-else chains when comparing a variable against multiple constants. The break statement prevents fall-through to subsequent cases."
            },
            {
              "type": "text",
              "content": "The ternary operator (condition ? value1 : value2) is a concise way to assign values based on a condition. It's equivalent to a simple if-else statement but more compact. Use it for simple conditional assignments, but prefer if-else for complex logic."
            },
            {
              "type": "text",
              "content": "For loops are ideal when you know the number of iterations in advance. They consist of initialization, condition, and increment/decrement expressions. The enhanced for loop (for-each) simplifies iteration over arrays and collections."
            },
            {
              "type": "text",
              "content": "While loops continue executing as long as a condition remains true. They're useful when you don't know the number of iterations beforehand. Always ensure the loop condition will eventually become false to avoid infinite loops."
            },
            {
              "type": "text",
              "content": "Do-while loops execute the loop body at least once before checking the condition. They're useful when you need to perform an action before evaluating whether to continue. This guarantees at least one execution of the loop body."
            },
            {
              "type": "text",
              "content": "Break and continue statements provide fine-grained control over loop execution. Break exits the loop entirely, while continue skips the rest of the current iteration and continues with the next one. These statements are essential for optimizing loop performance."
            },
            {
              "type": "text",
              "content": "Best practices for control flow:",
              "subsections": [
                "Use meaningful boolean expressions that clearly express intent",
                "Avoid deeply nested if statements - consider using early returns or switch statements",
                "Always use braces {} for control flow blocks, even for single statements",
                "Choose the appropriate loop type based on your specific needs",
                "Be careful with infinite loops - ensure loop conditions will eventually become false",
                "Use break and continue judiciously to improve code readability",
                "Consider performance implications when choosing between different control structures"
              ]
            },
            {
              "type": "text",
              "content": "Common control flow patterns include:",
              "subsections": [
                "Input Validation: Using if statements to check user input",
                "Menu Systems: Using switch statements for user choice processing",
                "Data Processing: Using loops to iterate through collections",
                "Error Handling: Using conditional statements to manage exceptions",
                "State Machines: Using switch statements to manage program states"
              ]
            }
          ]
        }
      },
      {
        "id": "java-1-6",
        "title": "Methods and Functions",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Methods in Java are blocks of code that perform specific tasks. They help organize code, promote reusability, and make programs more modular."
            },
            {
              "type": "code",
              "language": "java",
              "content": "public class Methods {\n    // Method with no parameters and no return value\n    public static void greet() {\n        System.out.println(\"Hello, World!\");\n    }\n    \n    // Method with parameters and return value\n    public static int add(int a, int b) {\n        return a + b;\n    }\n    \n    // Method with multiple parameters\n    public static String createFullName(String firstName, String lastName) {\n        return firstName + \" \" + lastName;\n    }\n    \n    // Method with default parameter (using method overloading)\n    public static int multiply(int a, int b) {\n        return a * b;\n    }\n    \n    public static int multiply(int a, int b, int c) {\n        return a * b * c;\n    }\n    \n    // Method with array parameter\n    public static int sumArray(int[] numbers) {\n        int sum = 0;\n        for (int number : numbers) {\n            sum += number;\n        }\n        return sum;\n    }\n    \n    // Method with variable arguments (varargs)\n    public static int sum(int... numbers) {\n        int total = 0;\n        for (int number : numbers) {\n            total += number;\n        }\n        return total;\n    }\n    \n    // Recursive method\n    public static int factorial(int n) {\n        if (n <= 1) {\n            return 1;\n        }\n        return n * factorial(n - 1);\n    }\n    \n    // Method with different return types\n    public static boolean isEven(int number) {\n        return number % 2 == 0;\n    }\n    \n    public static double calculateArea(double radius) {\n        return Math.PI * radius * radius;\n    }\n    \n    public static void main(String[] args) {\n        // Calling methods\n        greet();\n        \n        int result = add(5, 3);\n        System.out.println(\"Sum: \" + result);\n        \n        String fullName = createFullName(\"John\", \"Doe\");\n        System.out.println(\"Full name: \" + fullName);\n        \n        // Method overloading\n        System.out.println(\"Multiply 2 numbers: \" + multiply(2, 3));\n        System.out.println(\"Multiply 3 numbers: \" + multiply(2, 3, 4));\n        \n        // Array parameter\n        int[] numbers = {1, 2, 3, 4, 5};\n        System.out.println(\"Sum of array: \" + sumArray(numbers));\n        \n        // Variable arguments\n        System.out.println(\"Sum of 1,2,3: \" + sum(1, 2, 3));\n        System.out.println(\"Sum of 1,2,3,4,5: \" + sum(1, 2, 3, 4, 5));\n        \n        // Recursive method\n        System.out.println(\"Factorial of 5: \" + factorial(5));\n        \n        // Different return types\n        System.out.println(\"Is 6 even? \" + isEven(6));\n        System.out.println(\"Area of circle with radius 3: \" + calculateArea(3));\n    }\n}"
            },
            {
              "type": "text",
              "content": "Methods are essential for code organization and reusability. Understanding method signatures, parameters, and return types is crucial for effective Java programming."
            }
          ]
        }
      },
      {
        "id": "java-1-7",
        "title": "Classes and Objects",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Java is an object-oriented programming language. Classes are blueprints for creating objects, and objects are instances of classes that contain data and behavior."
            },
            {
              "type": "code",
              "language": "java",
              "content": "// Simple class definition\npublic class Person {\n    // Instance variables (attributes)\n    private String name;\n    private int age;\n    private String email;\n    \n    // Constructor\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    // Constructor with default values\n    public Person() {\n        this.name = \"Unknown\";\n        this.age = 0;\n    }\n    \n    // Getter methods\n    public String getName() {\n        return name;\n    }\n    \n    public int getAge() {\n        return age;\n    }\n    \n    public String getEmail() {\n        return email;\n    }\n    \n    // Setter methods\n    public void setName(String name) {\n        this.name = name;\n    }\n    \n    public void setAge(int age) {\n        if (age >= 0) {\n            this.age = age;\n        }\n    }\n    \n    public void setEmail(String email) {\n        this.email = email;\n    }\n    \n    // Instance method\n    public void introduce() {\n        System.out.println(\"Hello, I'm \" + name + \" and I'm \" + age + \" years old.\");\n    }\n    \n    // Method with parameters\n    public void greet(String greeting) {\n        System.out.println(greeting + \", I'm \" + name);\n    }\n    \n    // Method that returns a value\n    public boolean isAdult() {\n        return age >= 18;\n    }\n    \n    // Override toString method\n    @Override\n    public String toString() {\n        return \"Person{name='\" + name + \"', age=\" + age + \", email='\" + email + \"'}\";\n    }\n}\n\n// Main class to demonstrate object creation\npublic class ObjectOrientedDemo {\n    public static void main(String[] args) {\n        // Creating objects\n        Person person1 = new Person(\"John Doe\", 25);\n        Person person2 = new Person(\"Jane Smith\", 30);\n        Person person3 = new Person(); // Uses default constructor\n        \n        // Setting properties\n        person3.setName(\"Bob Johnson\");\n        person3.setAge(35);\n        person3.setEmail(\"bob@example.com\");\n        \n        // Calling methods\n        person1.introduce();\n        person2.greet(\"Good morning\");\n        \n        // Using getter methods\n        System.out.println(\"Person 1 name: \" + person1.getName());\n        System.out.println(\"Person 2 age: \" + person2.getAge());\n        \n        // Using boolean method\n        System.out.println(\"Is person1 adult? \" + person1.isAdult());\n        System.out.println(\"Is person3 adult? \" + person3.isAdult());\n        \n        // Using toString method\n        System.out.println(\"Person 3: \" + person3);\n        \n        // Creating an array of objects\n        Person[] people = {person1, person2, person3};\n        \n        System.out.println(\"\\nAll people:\");\n        for (Person person : people) {\n            person.introduce();\n        }\n    }\n}"
            },
            {
              "type": "text",
              "content": "Classes and objects are the foundation of object-oriented programming in Java. Understanding encapsulation, constructors, and method design is essential for creating robust applications."
            }
          ]
        }
      },
      {
        "id": "java-1-8",
        "title": "Arrays and Collections",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Arrays and collections are used to store and manage groups of data. Java provides various data structures for different use cases."
            },
            {
              "type": "code",
              "language": "java",
              "content": "import java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\n\npublic class ArraysAndCollections {\n    public static void main(String[] args) {\n        // Arrays\n        int[] numbers = {1, 2, 3, 4, 5};\n        String[] names = {\"Alice\", \"Bob\", \"Charlie\"};\n        \n        // Array declaration and initialization\n        int[] scores = new int[5];\n        scores[0] = 85;\n        scores[1] = 92;\n        scores[2] = 78;\n        scores[3] = 95;\n        scores[4] = 88;\n        \n        // Accessing array elements\n        System.out.println(\"First number: \" + numbers[0]);\n        System.out.println(\"Last name: \" + names[names.length - 1]);\n        \n        // Array length\n        System.out.println(\"Numbers array length: \" + numbers.length);\n        \n        // Iterating through arrays\n        System.out.println(\"\\nNumbers:\");\n        for (int i = 0; i < numbers.length; i++) {\n            System.out.println(\"Index \" + i + \": \" + numbers[i]);\n        }\n        \n        System.out.println(\"\\nNames:\");\n        for (String name : names) {\n            System.out.println(name);\n        }\n        \n        // Multi-dimensional arrays\n        int[][] matrix = {\n            {1, 2, 3},\n            {4, 5, 6},\n            {7, 8, 9}\n        };\n        \n        System.out.println(\"\\nMatrix:\");\n        for (int i = 0; i < matrix.length; i++) {\n            for (int j = 0; j < matrix[i].length; j++) {\n                System.out.print(matrix[i][j] + \" \");\n            }\n            System.out.println();\n        }\n        \n        // ArrayList (dynamic array)\n        ArrayList<String> fruits = new ArrayList<>();\n        fruits.add(\"Apple\");\n        fruits.add(\"Banana\");\n        fruits.add(\"Orange\");\n        fruits.add(\"Grape\");\n        \n        System.out.println(\"\\nFruits: \" + fruits);\n        System.out.println(\"Size: \" + fruits.size());\n        \n        // ArrayList operations\n        fruits.remove(\"Banana\");\n        fruits.add(1, \"Mango\");\n        \n        System.out.println(\"After modifications: \" + fruits);\n        \n        // Iterating through ArrayList\n        System.out.println(\"\\nFruits list:\");\n        for (String fruit : fruits) {\n            System.out.println(fruit);\n        }\n        \n        // HashMap (key-value pairs)\n        HashMap<String, Integer> ages = new HashMap<>();\n        ages.put(\"John\", 25);\n        ages.put(\"Jane\", 30);\n        ages.put(\"Bob\", 35);\n        \n        System.out.println(\"\\nAges: \" + ages);\n        System.out.println(\"John's age: \" + ages.get(\"John\"));\n        \n        // HashMap operations\n        ages.put(\"John\", 26); // Update existing key\n        ages.remove(\"Bob\");\n        \n        System.out.println(\"After modifications: \" + ages);\n        \n        // HashSet (unique elements)\n        HashSet<String> uniqueNames = new HashSet<>();\n        uniqueNames.add(\"Alice\");\n        uniqueNames.add(\"Bob\");\n        uniqueNames.add(\"Alice\"); // Duplicate, won't be added\n        uniqueNames.add(\"Charlie\");\n        \n        System.out.println(\"\\nUnique names: \" + uniqueNames);\n        \n        // Array utility methods\n        int[] unsorted = {5, 2, 8, 1, 9, 3};\n        System.out.println(\"\\nOriginal array: \" + Arrays.toString(unsorted));\n        \n        Arrays.sort(unsorted);\n        System.out.println(\"Sorted array: \" + Arrays.toString(unsorted));\n        \n        // Searching in sorted array\n        int searchKey = 8;\n        int index = Arrays.binarySearch(unsorted, searchKey);\n        System.out.println(\"Index of \" + searchKey + \": \" + index);\n        \n        // Array copying\n        int[] original = {1, 2, 3, 4, 5};\n        int[] copy = Arrays.copyOf(original, original.length);\n        System.out.println(\"\\nOriginal: \" + Arrays.toString(original));\n        System.out.println(\"Copy: \" + Arrays.toString(copy));\n    }\n}"
            },
            {
              "type": "text",
              "content": "Arrays are fixed-size collections, while ArrayList and other collections provide dynamic sizing and additional functionality. Choose the appropriate data structure based on your specific needs."
            }
          ]
        }
      }
    ],
    "quiz": {
      "questions": [
        {
          "question": "What is Java?",
          "options": [
            "A markup language for web pages",
            "A high-level, object-oriented programming language",
            "A database management system",
            "A web browser"
          ],
          "correct": 1,
          "explanation": "Java is a high-level, object-oriented programming language developed by Sun Microsystems (now Oracle) that is platform-independent."
        },
        {
          "question": "Which of the following is NOT a primitive data type in Java?",
          "options": [
            "int",
            "double",
            "String",
            "boolean"
          ],
          "correct": 2,
          "explanation": "String is a reference type in Java, not a primitive type. The primitive types are byte, short, int, long, float, double, char, and boolean."
        },
        {
          "question": "What is the purpose of the 'final' keyword in Java?",
          "options": [
            "To end a program",
            "To make a variable constant (unchangeable)",
            "To create a loop",
            "To define a method"
          ],
          "correct": 1,
          "explanation": "The 'final' keyword makes a variable constant, meaning its value cannot be changed after initialization."
        },
        {
          "question": "Which loop is best for iterating through an array when you need the index?",
          "options": [
            "for-each loop",
            "while loop",
            "traditional for loop",
            "do-while loop"
          ],
          "correct": 2,
          "explanation": "The traditional for loop with an index variable is best when you need to know the position of elements in an array."
        },
        {
          "question": "What is encapsulation in Java?",
          "options": [
            "Combining multiple classes into one",
            "Hiding data and methods within a class",
            "Creating multiple objects from a class",
            "Inheriting from another class"
          ],
          "correct": 1,
          "explanation": "Encapsulation is the bundling of data and methods that operate on that data within a single unit (class) and hiding the internal state."
        }
      ]
    }
  }
} 