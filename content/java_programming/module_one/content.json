{
  "module": {
    "title": "Introduction to Java",
    "description": "Learn the fundamentals of Java programming, object-oriented concepts, and basic syntax",
    "lessons": [
      {
        "id": "java-1-1",
        "title": "What is Java?",
        "duration": "30 minutes",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Java is a high-level, object-oriented programming language developed by Sun Microsystems (now Oracle) in 1995. It's designed to be platform-independent, meaning Java programs can run on any device that has a Java Virtual Machine (JVM)."
            },
            {
              "type": "text",
              "content": "Key features of Java:",
              "subsections": [
                "Platform independent - Write once, run anywhere",
                "Object-oriented programming language",
                "Strongly typed with static type checking",
                "Automatic memory management (garbage collection)",
                "Rich standard library and ecosystem",
                "Secure and robust"
              ]
            },
            {
              "type": "code",
              "language": "java",
              "content": "// Simple Java program\npublic class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, World!\");\n    }\n}"
            }
          ]
        }
      },
      {
        "id": "java-1-2",
        "title": "Setting Up Java Development Environment",
        "duration": "45 minutes",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "To start programming in Java, you need to set up the Java Development Kit (JDK) and an Integrated Development Environment (IDE)."
            },
            {
              "type": "text",
              "content": "Setup steps:",
              "subsections": [
                "Download and install JDK (Java Development Kit)",
                "Set up JAVA_HOME environment variable",
                "Install an IDE (Eclipse, IntelliJ IDEA, or VS Code)",
                "Verify installation with command line tools"
              ]
            },
            {
              "type": "code",
              "language": "bash",
              "content": "# Check Java version\njava -version\njavac -version\n\n# Set JAVA_HOME (Windows)\nset JAVA_HOME=C:\\Program Files\\Java\\jdk-17\n\n# Set JAVA_HOME (macOS/Linux)\nexport JAVA_HOME=/usr/lib/jvm/java-17-openjdk\n\n# Add Java to PATH\n# Windows: %JAVA_HOME%\\bin\n# macOS/Linux: $JAVA_HOME/bin"
            },
            {
              "type": "code",
              "language": "java",
              "content": "// First Java program\npublic class FirstProgram {\n    public static void main(String[] args) {\n        System.out.println(\"Welcome to Java Programming!\");\n        \n        // Print Java version\n        System.out.println(\"Java Version: \" + System.getProperty(\"java.version\"));\n    }\n}"
            }
          ]
        }
      },
      {
        "id": "java-1-3",
        "title": "Basic Syntax and Data Types",
        "duration": "60 minutes",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Java is a strongly-typed language, meaning every variable must have a declared type. Understanding the basic syntax and data types is fundamental to Java programming."
            },
            {
              "type": "text",
              "content": "Java's type system is designed to catch errors at compile time rather than runtime, making programs more reliable and efficient. Every variable, parameter, and return value must have a specific type declared, which helps prevent type-related bugs and improves code readability."
            },
            {
              "type": "text",
              "content": "Java data types are categorized into two main groups:",
              "subsections": [
                "Primitive Types: Basic data types stored directly in memory (byte, short, int, long, float, double, char, boolean)",
                "Reference Types: Complex types that store references to objects (classes, interfaces, arrays, enums)"
              ]
            },
            {
              "type": "text",
              "content": "Key characteristics of Java's type system:",
              "subsections": [
                "Static Typing: Types are checked at compile time",
                "Type Safety: Prevents incompatible type assignments",
                "Memory Efficiency: Primitive types use minimal memory",
                "Object-Oriented: Reference types support inheritance and polymorphism",
                "Automatic Boxing: Automatic conversion between primitives and wrapper classes"
              ]
            },
            {
              "type": "text",
              "content": "Understanding data types is crucial for memory management, performance optimization, and writing maintainable code. Choosing the right data type can significantly impact your program's efficiency and correctness."
            },
            {
              "type": "code",
              "language": "java",
              "content": "public class DataTypes {\n    public static void main(String[] args) {\n        // Primitive data types\n        int intValue = 42;\n        double doubleValue = 3.14;\n        char charValue = 'A';\n        boolean booleanValue = true;\n        \n        // Reference data types\n        String stringValue = \"Hello, Java!\";\n        \n        // Arrays\n        int[] numbers = {1, 2, 3};\n        \n        // Printing values\n        System.out.println(\"Int: \" + intValue);\n        System.out.println(\"Double: \" + doubleValue);\n        System.out.println(\"Char: \" + charValue);\n        System.out.println(\"Boolean: \" + booleanValue);\n        System.out.println(\"String: \" + stringValue);\n        \n        // Type conversion\n        int intFromDouble = (int) doubleValue;\n        System.out.println(\"Int from double: \" + intFromDouble);\n    }\n}"
            },
            {
              "type": "text",
              "content": "Java has two categories of data types: primitive types (stored directly in memory) and reference types (stored as references to objects). Understanding the difference is crucial for memory management and performance."
            },
            {
              "type": "text",
              "content": "Primitive data types are the building blocks of Java programming. They represent simple values and are stored directly in memory, making them very efficient for basic operations. Each primitive type has a specific size and range of values it can hold."
            },
            {
              "type": "text",
              "content": "Integer primitive types (in order of size):",
              "subsections": [
                "byte: 8-bit signed integer (-128 to 127), used for small numbers to save memory",
                "short: 16-bit signed integer (-32,768 to 32,767), used for medium-sized numbers",
                "int: 32-bit signed integer (-2^31 to 2^31-1), most commonly used integer type",
                "long: 64-bit signed integer (-2^63 to 2^63-1), used for very large numbers"
              ]
            },
            {
              "type": "text",
              "content": "Floating-point primitive types:",
              "subsections": [
                "float: 32-bit floating point, 6-7 decimal digits precision, suffix 'f' required",
                "double: 64-bit floating point, 15-16 decimal digits precision, default for decimals"
              ]
            },
            {
              "type": "text",
              "content": "Other primitive types:",
              "subsections": [
                "char: 16-bit Unicode character, represents a single character",
                "boolean: true or false value, used for logical operations and conditions"
              ]
            },
            {
              "type": "text",
              "content": "Reference types include arrays, classes, interfaces, and enums. They are stored as references (memory addresses) pointing to objects in the heap. Arrays are special reference types that can hold multiple values of the same type."
            },
            {
              "type": "text",
              "content": "Type conversion (casting) is necessary when assigning values between different types. Implicit conversion happens when no data loss occurs, while explicit casting is required when there's potential for data loss."
            },
            {
              "type": "text",
              "content": "Wrapper classes (Integer, Double, Boolean, etc.) provide object representations of primitive types. They are useful when you need to store primitives in collections or when working with generics."
            },
            {
              "type": "text",
              "content": "Memory considerations: Primitive types are stored on the stack and are very memory-efficient, while reference types are stored on the heap and require more memory due to object overhead."
            }
          ]
        }
      },
      {
        "id": "java-1-4",
        "title": "Variables and Operators",
        "duration": "45 minutes",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Variables in Java must be declared with a specific type and can be initialized with values. Java provides various operators for performing operations on variables and values."
            },
            {
              "type": "text",
              "content": "Variables are fundamental building blocks in Java programming that allow you to store and manipulate data. They serve as named containers for values that can change during program execution. Understanding variables and operators is essential for writing effective Java programs."
            },
            {
              "type": "text",
              "content": "Variable declaration and initialization:",
              "subsections": [
                "Declaration: Specifying the variable type and name (e.g., int age;)",
                "Initialization: Assigning an initial value to the variable (e.g., int age = 25;)",
                "Declaration and Initialization: Combining both in one statement",
                "Constants: Using final keyword to create immutable variables",
                "Scope: Understanding where variables can be accessed"
              ]
            },
            {
              "type": "text",
              "content": "Variable naming conventions in Java:",
              "subsections": [
                "Camel Case: Use camelCase for variable names (e.g., firstName, totalAmount)",
                "Descriptive Names: Choose names that clearly indicate the variable's purpose",
                "Avoid Keywords: Don't use Java reserved words as variable names",
                "Start with Letter: Variable names must start with a letter, underscore, or dollar sign",
                "Case Sensitive: Java is case-sensitive, so age and Age are different variables"
              ]
            },
            {
              "type": "text",
              "content": "Java operators are symbols that perform operations on operands (variables, literals, or expressions). They are categorized into different types based on their functionality and the number of operands they work with."
            },
            {
              "type": "code",
              "language": "java",
              "content": "public class VariablesAndOperators {\n    public static void main(String[] args) {\n        // Variable declaration\n        int age = 25;\n        String name = \"John\";\n        \n        // Constants\n        final double PI = 3.14;\n        \n        // Arithmetic operators\n        int a = 10;\n        int b = 3;\n        \n        System.out.println(\"Addition: \" + (a + b));\n        System.out.println(\"Division: \" + (a / b));\n        \n        // Comparison operators\n        System.out.println(\"a < b: \" + (a < b));\n        \n        // Logical operators\n        boolean isTrue = true;\n        boolean isFalse = false;\n        System.out.println(\"AND: \" + (isTrue && isFalse));\n        \n        // String concatenation\n        String fullName = name + \" Doe\";\n        System.out.println(\"Full name: \" + fullName);\n    }\n}"
            },
            {
              "type": "text",
              "content": "Java operators follow precedence rules. Understanding operator precedence helps avoid unexpected results in complex expressions."
            },
            {
              "type": "text",
              "content": "Arithmetic operators perform mathematical operations on numeric values. They include addition (+), subtraction (-), multiplication (*), division (/), and modulus (%). The modulus operator returns the remainder of a division operation and is useful for determining if a number is even or odd."
            },
            {
              "type": "text",
              "content": "Increment and decrement operators (++ and --) are used to increase or decrease a variable's value by 1. They can be used in prefix (++x) or postfix (x++) form. The difference is when the increment/decrement occurs relative to the expression evaluation."
            },
            {
              "type": "text",
              "content": "Assignment operators combine assignment with arithmetic operations. They provide a shorthand way to modify variables. Common assignment operators include +=, -=, *=, /=, and %=. These operators are more efficient than separate arithmetic and assignment operations."
            },
            {
              "type": "text",
              "content": "Comparison operators are used to compare values and return boolean results. They include equality (==), inequality (!=), less than (<), greater than (>), less than or equal (<=), and greater than or equal (>=). These operators are essential for conditional statements and loops."
            },
            {
              "type": "text",
              "content": "Logical operators work with boolean values and are used in conditional expressions. The AND operator (&&) returns true only if both operands are true. The OR operator (||) returns true if at least one operand is true. The NOT operator (!) inverts the boolean value."
            },
            {
              "type": "text",
              "content": "String concatenation uses the + operator to join strings together. Java automatically converts non-string values to strings when concatenating. The String.format() method provides more control over string formatting with placeholders for different data types."
            },
            {
              "type": "text",
              "content": "Operator precedence determines the order in which operations are performed. Understanding precedence is crucial for writing correct expressions. Parentheses can be used to override the default precedence and make expressions more readable."
            },
            {
              "type": "text",
              "content": "Best practices for variables and operators:",
              "subsections": [
                "Use meaningful variable names that clearly indicate their purpose",
                "Initialize variables when declaring them to avoid undefined behavior",
                "Use constants (final) for values that should not change",
                "Be careful with floating-point arithmetic due to precision issues",
                "Use parentheses to clarify complex expressions and avoid precedence confusion",
                "Choose appropriate data types to optimize memory usage and performance"
              ]
            }
          ]
        }
      },
      {
        "id": "java-1-5",
        "title": "Control Flow Statements",
        "duration": "60 minutes",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Control flow statements allow you to control the execution of your program based on conditions and loops. These are essential for creating dynamic and responsive applications."
            },
            {
              "type": "text",
              "content": "Control flow statements are the backbone of program logic, enabling you to make decisions and repeat actions based on conditions. They transform static code into dynamic, responsive applications that can adapt to different situations and user inputs."
            },
            {
              "type": "text",
              "content": "Types of control flow statements in Java:",
              "subsections": [
                "Conditional Statements: if, if-else, if-else-if-else for decision making",
                "Switch Statements: Multi-way branching based on a single variable",
                "Loop Statements: for, while, do-while for repetitive execution",
                "Jump Statements: break, continue, return for flow control",
                "Ternary Operator: Shorthand conditional expression"
              ]
            },
            {
              "type": "text",
              "content": "Conditional statements evaluate boolean expressions and execute different code blocks based on the result. They enable programs to respond differently to various conditions, making applications interactive and intelligent."
            },
            {
              "type": "text",
              "content": "Loop statements allow you to execute a block of code multiple times. They are essential for processing collections of data, implementing algorithms, and creating interactive programs. Each loop type has specific use cases and advantages."
            },
            {
              "type": "text",
              "content": "Understanding control flow is crucial for:",
              "subsections": [
                "User Input Processing: Responding to different user choices",
                "Data Validation: Checking input values and data integrity",
                "Algorithm Implementation: Creating complex computational logic",
                "Error Handling: Managing different error conditions",
                "Performance Optimization: Controlling program execution efficiently"
              ]
            },
            {
              "type": "code",
              "language": "java",
              "content": "public class ControlFlow {\n    public static void main(String[] args) {\n        // If statement\n        int age = 18;\n        \n        if (age >= 18) {\n            System.out.println(\"You are an adult\");\n        } else {\n            System.out.println(\"You are a minor\");\n        }\n        \n        // Switch statement\n        int day = 1;\n        String dayName;\n        \n        switch (day) {\n            case 1:\n                dayName = \"Monday\";\n                break;\n            case 2:\n                dayName = \"Tuesday\";\n                break;\n            default:\n                dayName = \"Other day\";\n        }\n        \n        System.out.println(\"Day: \" + dayName);\n        \n        // For loop\n        System.out.println(\"\\nFor loop:\");\n        for (int i = 0; i < 3; i++) {\n            System.out.println(\"Iteration \" + i);\n        }\n        \n        // While loop\n        System.out.println(\"\\nWhile loop:\");\n        int count = 0;\n        while (count < 2) {\n            System.out.println(\"Count: \" + count);\n            count++;\n        }\n        \n        // Enhanced for loop\n        System.out.println(\"\\nEnhanced for loop:\");\n        String[] colors = {\"Red\", \"Green\"};\n        for (String color : colors) {\n            System.out.println(\"Color: \" + color);\n        }\n    }\n}"
            },
            {
              "type": "text",
              "content": "Control flow statements are fundamental to programming logic. Understanding when to use each type of statement helps create efficient and readable code."
            },
            {
              "type": "text",
              "content": "If statements are the most basic form of conditional execution. They evaluate a boolean expression and execute the code block only if the condition is true. The if-else structure provides an alternative path when the condition is false."
            },
            {
              "type": "text",
              "content": "If-else-if-else chains allow for multiple conditions to be evaluated in sequence. Each condition is checked only if all previous conditions were false. This structure is useful for handling multiple mutually exclusive scenarios."
            },
            {
              "type": "text",
              "content": "Switch statements provide an efficient way to handle multiple possible values of a single variable. They are more readable than long if-else chains when comparing a variable against multiple constants. The break statement prevents fall-through to subsequent cases."
            },
            {
              "type": "text",
              "content": "The ternary operator (condition ? value1 : value2) is a concise way to assign values based on a condition. It's equivalent to a simple if-else statement but more compact. Use it for simple conditional assignments, but prefer if-else for complex logic."
            },
            {
              "type": "text",
              "content": "For loops are ideal when you know the number of iterations in advance. They consist of initialization, condition, and increment/decrement expressions. The enhanced for loop (for-each) simplifies iteration over arrays and collections."
            },
            {
              "type": "text",
              "content": "While loops continue executing as long as a condition remains true. They're useful when you don't know the number of iterations beforehand. Always ensure the loop condition will eventually become false to avoid infinite loops."
            },
            {
              "type": "text",
              "content": "Do-while loops execute the loop body at least once before checking the condition. They're useful when you need to perform an action before evaluating whether to continue. This guarantees at least one execution of the loop body."
            },
            {
              "type": "text",
              "content": "Break and continue statements provide fine-grained control over loop execution. Break exits the loop entirely, while continue skips the rest of the current iteration and continues with the next one. These statements are essential for optimizing loop performance."
            },
            {
              "type": "text",
              "content": "Best practices for control flow:",
              "subsections": [
                "Use meaningful boolean expressions that clearly express intent",
                "Avoid deeply nested if statements - consider using early returns or switch statements",
                "Always use braces {} for control flow blocks, even for single statements",
                "Choose the appropriate loop type based on your specific needs",
                "Be careful with infinite loops - ensure loop conditions will eventually become false",
                "Use break and continue judiciously to improve code readability",
                "Consider performance implications when choosing between different control structures"
              ]
            },
            {
              "type": "text",
              "content": "Common control flow patterns include:",
              "subsections": [
                "Input Validation: Using if statements to check user input",
                "Menu Systems: Using switch statements for user choice processing",
                "Data Processing: Using loops to iterate through collections",
                "Error Handling: Using conditional statements to manage exceptions",
                "State Machines: Using switch statements to manage program states"
              ]
            }
          ]
        }
      },
      {
        "id": "java-1-6",
        "title": "Methods and Functions",
        "duration": "45 minutes",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Methods in Java are blocks of code that perform specific tasks. They help organize code, promote reusability, and make programs more modular."
            },
            {
              "type": "text",
              "content": "Methods are fundamental building blocks of Java programming that encapsulate functionality into reusable units. They enable code organization, reduce duplication, and make programs easier to understand and maintain. Methods are essential for creating modular, scalable applications."
            },
            {
              "type": "text",
              "content": "Key benefits of using methods:",
              "subsections": [
                "Code Reusability: Write once, use many times across your program",
                "Modularity: Break complex problems into smaller, manageable pieces",
                "Maintainability: Easier to update and debug specific functionality",
                "Readability: Code becomes more self-documenting and easier to understand",
                "Testing: Individual methods can be tested in isolation",
                "Abstraction: Hide implementation details behind a simple interface"
              ]
            },
            {
              "type": "text",
              "content": "Method components and structure:",
              "subsections": [
                "Access Modifier: Controls visibility (public, private, protected, default)",
                "Return Type: Data type of the value returned (void for no return)",
                "Method Name: Descriptive name following camelCase convention",
                "Parameters: Input values the method needs to perform its task",
                "Method Body: The actual code that performs the operation",
                "Return Statement: Sends a value back to the calling code"
              ]
            },
            {
              "type": "text",
              "content": "Types of methods in Java:",
              "subsections": [
                "Instance Methods: Belong to objects and can access instance variables",
                "Static Methods: Belong to classes and can be called without creating objects",
                "Constructor Methods: Special methods for initializing objects",
                "Getter/Setter Methods: Access and modify object properties",
                "Utility Methods: Perform common operations and calculations"
              ]
            },
            {
              "type": "text",
              "content": "Method overloading allows you to define multiple methods with the same name but different parameters. This enables you to provide different ways to call the same functionality, making your API more flexible and user-friendly."
            },
            {
              "type": "text",
              "content": "Variable arguments (varargs) allow methods to accept a variable number of arguments. This is useful for methods that need to handle different numbers of inputs, such as mathematical operations or utility functions."
            },
            {
              "type": "code",
              "language": "java",
              "content": "public class Methods {\n    // Method with no parameters and no return value\n    public static void greet() {\n        System.out.println(\"Hello, World!\");\n    }\n    \n    // Method with parameters and return value\n    public static int add(int a, int b) {\n        return a + b;\n    }\n    \n    // Method overloading\n    public static int multiply(int a, int b) {\n        return a * b;\n    }\n    \n    public static int multiply(int a, int b, int c) {\n        return a * b * c;\n    }\n    \n    // Method with different return types\n    public static boolean isEven(int number) {\n        return number % 2 == 0;\n    }\n    \n    public static void main(String[] args) {\n        // Calling methods\n        greet();\n        \n        int result = add(5, 3);\n        System.out.println(\"Sum: \" + result);\n        \n        // Method overloading\n        System.out.println(\"Multiply 2 numbers: \" + multiply(2, 3));\n        System.out.println(\"Multiply 3 numbers: \" + multiply(2, 3, 4));\n        \n        // Different return types\n        System.out.println(\"Is 6 even? \" + isEven(6));\n    }\n}"
            },
            {
              "type": "text",
              "content": "Methods are essential for code organization and reusability. Understanding method signatures, parameters, and return types is crucial for effective Java programming."
            },
            {
              "type": "text",
              "content": "Method signatures define the contract that callers must follow. They include the method name, parameter types, and return type. A well-designed method signature makes the method's purpose clear and easy to use correctly."
            },
            {
              "type": "text",
              "content": "Parameters allow methods to receive input data from the calling code. They enable methods to be flexible and reusable with different inputs. Parameters are passed by value in Java, meaning the method receives a copy of the original value."
            },
            {
              "type": "text",
              "content": "Return types specify what kind of data the method sends back to the caller. The void return type indicates that the method doesn't return any value. Choosing appropriate return types helps make methods more useful and predictable."
            },
            {
              "type": "text",
              "content": "Method overloading is a form of polymorphism that allows multiple methods with the same name but different parameter lists. The compiler determines which method to call based on the arguments provided. This technique improves API design and code readability."
            },
            {
              "type": "text",
              "content": "Variable arguments (varargs) use the ellipsis (...) syntax to accept any number of arguments of the same type. The arguments are automatically packaged into an array within the method. Varargs must be the last parameter in the method signature."
            },
            {
              "type": "text",
              "content": "Recursive methods call themselves to solve problems that can be broken down into smaller, similar subproblems. They require a base case to prevent infinite recursion. Recursion is elegant for certain algorithms but can be less efficient than iterative solutions."
            },
            {
              "type": "text",
              "content": "Method design principles:",
              "subsections": [
                "Single Responsibility: Each method should do one thing well",
                "Descriptive Names: Method names should clearly indicate their purpose",
                "Appropriate Parameters: Pass only the data the method needs",
                "Return Values: Return meaningful results that callers can use",
                "Error Handling: Consider what happens when parameters are invalid",
                "Documentation: Comment complex methods to explain their behavior"
              ]
            },
            {
              "type": "text",
              "content": "Common method patterns:",
              "subsections": [
                "Utility Methods: Static methods for common operations",
                "Factory Methods: Create and return objects with specific configurations",
                "Validation Methods: Check if data meets certain criteria",
                "Conversion Methods: Transform data from one format to another",
                "Calculation Methods: Perform mathematical or logical operations",
                "Accessor Methods: Get and set object properties safely"
              ]
            },
            {
              "type": "text",
              "content": "Best practices for method design:",
              "subsections": [
                "Keep methods short and focused on a single task",
                "Use meaningful parameter and variable names",
                "Avoid side effects - methods should do what their name suggests",
                "Consider performance implications of method calls",
                "Use appropriate access modifiers to control visibility",
                "Test methods independently to ensure reliability",
                "Document complex algorithms and business logic"
              ]
            }
          ]
        }
      },
      {
        "id": "java-1-7",
        "title": "Classes and Objects",
        "duration": "60 minutes",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Java is an object-oriented programming language. Classes are blueprints for creating objects, and objects are instances of classes that contain data and behavior."
            },
            {
              "type": "text",
              "content": "Object-Oriented Programming (OOP) is a programming paradigm that organizes code around objects rather than functions and logic. In Java, everything is built around classes and objects, making it a pure object-oriented language."
            },
            {
              "type": "text",
              "content": "Classes serve as templates or blueprints that define the structure and behavior of objects. They encapsulate data (attributes) and methods (behavior) into a single unit. Classes provide a way to model real-world entities in code."
            },
            {
              "type": "text",
              "content": "Objects are instances of classes that contain actual data and can perform actions. Each object has its own state (values of attributes) but shares the same behavior (methods) defined in the class. Objects represent specific instances of the class concept."
            },
            {
              "type": "text",
              "content": "Key concepts of classes and objects:",
              "subsections": [
                "Encapsulation: Bundling data and methods that operate on that data",
                "Data Hiding: Using access modifiers to control visibility of class members",
                "Instance Variables: Data that belongs to individual objects",
                "Instance Methods: Behavior that operates on object data",
                "Constructors: Special methods for initializing new objects",
                "Getters and Setters: Methods for accessing and modifying object state"
              ]
            },
            {
              "type": "text",
              "content": "Class structure and components:",
              "subsections": [
                "Class Declaration: Access modifier, class name, and inheritance",
                "Instance Variables: Fields that store object data",
                "Constructors: Methods that initialize new objects",
                "Instance Methods: Behavior that operates on object data",
                "Accessor Methods: Getters and setters for controlled access",
                "toString Method: String representation of the object"
              ]
            },
            {
              "type": "text",
              "content": "Benefits of object-oriented programming:",
              "subsections": [
                "Modularity: Code is organized into logical, reusable units",
                "Reusability: Classes can be used to create multiple objects",
                "Maintainability: Changes to one object don't affect others",
                "Scalability: Easy to extend and modify existing classes",
                "Abstraction: Complex systems can be simplified through objects",
                "Polymorphism: Objects can be treated as instances of their parent class"
              ]
            },
            {
              "type": "code",
              "language": "java",
              "content": "public class Person {\n    // Instance variables\n    private String name;\n    private int age;\n    \n    // Constructor\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    // Getter methods\n    public String getName() {\n        return name;\n    }\n    \n    public int getAge() {\n        return age;\n    }\n    \n    // Instance method\n    public void introduce() {\n        System.out.println(\"Hello, I'm \" + name + \" and I'm \" + age + \" years old.\");\n    }\n    \n    // Method that returns a value\n    public boolean isAdult() {\n        return age >= 18;\n    }\n}\n\npublic class ObjectOrientedDemo {\n    public static void main(String[] args) {\n        // Creating objects\n        Person person1 = new Person(\"John Doe\", 25);\n        Person person2 = new Person(\"Jane Smith\", 30);\n        \n        // Calling methods\n        person1.introduce();\n        \n        // Using getter methods\n        System.out.println(\"Person 1 name: \" + person1.getName());\n        \n        // Using boolean method\n        System.out.println(\"Is person1 adult? \" + person1.isAdult());\n    }\n}"
            },
            {
              "type": "text",
              "content": "Classes and objects are the foundation of object-oriented programming in Java. Understanding encapsulation, constructors, and method design is essential for creating robust applications."
            },
            {
              "type": "text",
              "content": "Instance variables (also called fields or attributes) store the data that belongs to each object. They define the state of the object and are declared at the class level. Each object gets its own copy of these variables, allowing objects to have different states."
            },
            {
              "type": "text",
              "content": "Constructors are special methods that initialize new objects. They have the same name as the class and are called automatically when a new object is created. Constructors can be overloaded to provide different ways of initializing objects."
            },
            {
              "type": "text",
              "content": "Access modifiers control the visibility of class members. Private members can only be accessed within the class, while public members can be accessed from anywhere. This encapsulation helps maintain data integrity and provides a clean interface."
            },
            {
              "type": "text",
              "content": "Getter and setter methods provide controlled access to private instance variables. Getters return the value of a field, while setters modify it, often including validation logic. This pattern ensures data integrity and provides a clean API."
            },
            {
              "type": "text",
              "content": "The toString() method provides a string representation of an object. It's automatically called when an object is printed or concatenated with a string. Overriding toString() makes debugging easier and provides meaningful object descriptions."
            },
            {
              "type": "text",
              "content": "Object creation and lifecycle:",
              "subsections": [
                "Instantiation: Creating new objects using the new keyword",
                "Initialization: Setting up object state through constructors",
                "Object State: The current values of all instance variables",
                "Method Calls: Invoking behavior on objects",
                "Garbage Collection: Automatic cleanup of unused objects"
              ]
            },
            {
              "type": "text",
              "content": "Class design principles:",
              "subsections": [
                "Single Responsibility: Each class should have one clear purpose",
                "Encapsulation: Hide internal state and provide controlled access",
                "Cohesion: Class members should be closely related",
                "Coupling: Minimize dependencies between classes",
                "Abstraction: Hide complex implementation details",
                "Information Hiding: Expose only what's necessary"
              ]
            },
            {
              "type": "text",
              "content": "Common class patterns:",
              "subsections": [
                "Entity Classes: Represent real-world objects (Person, Product)",
                "Utility Classes: Provide static methods for common operations",
                "Service Classes: Handle business logic and operations",
                "Data Transfer Objects (DTOs): Carry data between layers",
                "Value Objects: Immutable objects representing values",
                "Builder Classes: Create complex objects step by step"
              ]
            },
            {
              "type": "text",
              "content": "Best practices for class design:",
              "subsections": [
                "Use meaningful class names that clearly indicate purpose",
                "Keep classes focused and avoid god classes with too many responsibilities",
                "Use appropriate access modifiers to control visibility",
                "Provide constructors that ensure objects are in a valid state",
                "Override equals(), hashCode(), and toString() when appropriate",
                "Document complex classes and methods with clear comments",
                "Follow the principle of least privilege for access control"
              ]
            }
          ]
        }
      },
      {
        "id": "java-1-8",
        "title": "Arrays and Collections",
        "duration": "45 minutes",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Arrays and collections are used to store and manage groups of data. Java provides various data structures for different use cases."
            },
            {
              "type": "text",
              "content": "Data structures are fundamental to programming as they allow you to organize and manage collections of related data efficiently. Arrays and collections provide different approaches to storing multiple values, each with their own advantages and use cases."
            },
            {
              "type": "text",
              "content": "Arrays are the most basic data structure in Java. They store multiple values of the same type in contiguous memory locations, providing fast access to elements through indexing. Arrays have a fixed size that must be declared when they are created."
            },
            {
              "type": "text",
              "content": "The Collections Framework is a comprehensive set of interfaces and classes that provide more sophisticated data structures. It includes dynamic collections that can grow and shrink as needed, offering greater flexibility than arrays."
            },
            {
              "type": "text",
              "content": "Key characteristics of arrays:",
              "subsections": [
                "Fixed Size: Length is determined at creation and cannot be changed",
                "Indexed Access: Elements are accessed using zero-based indices",
                "Contiguous Memory: Elements are stored in adjacent memory locations",
                "Type Safety: All elements must be of the same type",
                "Fast Access: O(1) time complexity for random access",
                "Memory Efficiency: Minimal overhead for storing data"
              ]
            },
            {
              "type": "text",
              "content": "Types of collections in the Collections Framework:",
              "subsections": [
                "Lists: Ordered collections that allow duplicates (ArrayList, LinkedList)",
                "Sets: Collections that do not allow duplicates (HashSet, TreeSet)",
                "Maps: Key-value pairs for associative data (HashMap, TreeMap)",
                "Queues: Collections for processing elements in order (PriorityQueue)",
                "Stacks: Last-in-first-out collections (Stack class)"
              ]
            },
            {
              "type": "text",
              "content": "When to use arrays vs collections:",
              "subsections": [
                "Use Arrays: When you know the size in advance and need maximum performance",
                "Use Collections: When you need dynamic sizing or specialized functionality",
                "Use Arrays: For primitive types when memory efficiency is critical",
                "Use Collections: When you need built-in methods for searching, sorting, or filtering",
                "Use Arrays: For simple, straightforward data storage",
                "Use Collections: For complex data manipulation and algorithm implementation"
              ]
            },
            {
              "type": "code",
              "language": "java",
              "content": "import java.util.ArrayList;\nimport java.util.HashMap;\n\npublic class ArraysAndCollections {\n    public static void main(String[] args) {\n        // Arrays\n        int[] numbers = {1, 2, 3};\n        String[] names = {\"Alice\", \"Bob\"};\n        \n        // Accessing array elements\n        System.out.println(\"First number: \" + numbers[0]);\n        System.out.println(\"Array length: \" + numbers.length);\n        \n        // Iterating through arrays\n        for (int number : numbers) {\n            System.out.println(\"Number: \" + number);\n        }\n        \n        // ArrayList\n        ArrayList<String> fruits = new ArrayList<>();\n        fruits.add(\"Apple\");\n        fruits.add(\"Banana\");\n        \n        System.out.println(\"Fruits: \" + fruits);\n        \n        // HashMap\n        HashMap<String, Integer> ages = new HashMap<>();\n        ages.put(\"John\", 25);\n        ages.put(\"Jane\", 30);\n        \n        System.out.println(\"John's age: \" + ages.get(\"John\"));\n    }\n}"
            },
            {
              "type": "text",
              "content": "Arrays are fixed-size collections, while ArrayList and other collections provide dynamic sizing and additional functionality. Choose the appropriate data structure based on your specific needs."
            },
            {
              "type": "text",
              "content": "Array operations include declaration, initialization, access, and iteration. Arrays provide the fastest access to elements but lack flexibility in size management. They are ideal for scenarios where the size is known and performance is critical."
            },
            {
              "type": "text",
              "content": "Multi-dimensional arrays store data in a grid-like structure. They are useful for representing matrices, tables, and spatial data. Each dimension can have different lengths, allowing for irregular structures."
            },
            {
              "type": "text",
              "content": "ArrayList is the most commonly used collection in Java. It provides dynamic sizing, automatic resizing, and a rich set of methods for manipulation. ArrayList is backed by an array internally, providing a good balance of performance and flexibility."
            },
            {
              "type": "text",
              "content": "HashMap provides key-value storage with fast lookup times. It uses hashing to achieve O(1) average time complexity for get and put operations. HashMap is ideal for scenarios where you need to associate data with unique identifiers."
            },
            {
              "type": "text",
              "content": "HashSet ensures that each element appears only once in the collection. It uses hashing for fast membership testing and is ideal for removing duplicates from data sets. HashSet does not maintain insertion order."
            },
            {
              "type": "text",
              "content": "Array utility methods in the Arrays class provide common operations like sorting, searching, copying, and filling. These methods are optimized and handle edge cases, making them preferable to custom implementations."
            },
            {
              "type": "text",
              "content": "Collection iteration patterns:",
              "subsections": [
                "Traditional for loop: When you need the index or want to modify elements",
                "Enhanced for loop (for-each): For read-only iteration over all elements",
                "Iterator: When you need to remove elements during iteration",
                "Stream API: For functional programming style operations",
                "forEach method: For simple operations on each element"
              ]
            },
            {
              "type": "text",
              "content": "Performance considerations:",
              "subsections": [
                "Arrays: Fastest access but fixed size and limited functionality",
                "ArrayList: Good balance of performance and flexibility",
                "LinkedList: Fast insertions/deletions but slower random access",
                "HashMap: Fast lookups but uses more memory",
                "HashSet: Fast membership testing but no ordering",
                "TreeMap/TreeSet: Ordered but slower than hash-based collections"
              ]
            },
            {
              "type": "text",
              "content": "Best practices for data structures:",
              "subsections": [
                "Choose the right collection based on your access patterns",
                "Use generics to ensure type safety",
                "Initialize collections with appropriate initial capacity when possible",
                "Consider thread safety for concurrent applications",
                "Use utility methods instead of custom implementations",
                "Profile performance-critical code to choose optimal data structures",
                "Document the choice of data structure and its rationale"
              ]
            }
          ]
        }
      }
    ],
    "quiz": {
      "questions": [
        {
          "question": "What is Java?",
          "options": [
            "A markup language for web pages",
            "A high-level, object-oriented programming language",
            "A database management system",
            "A web browser"
          ],
          "correct": 1,
          "explanation": "Java is a high-level, object-oriented programming language developed by Sun Microsystems (now Oracle) that is platform-independent."
        },
        {
          "question": "Which of the following is NOT a primitive data type in Java?",
          "options": [
            "int",
            "double",
            "String",
            "boolean"
          ],
          "correct": 2,
          "explanation": "String is a reference type in Java, not a primitive type. The primitive types are byte, short, int, long, float, double, char, and boolean."
        },
        {
          "question": "What is the purpose of the 'final' keyword in Java?",
          "options": [
            "To end a program",
            "To make a variable constant (unchangeable)",
            "To create a loop",
            "To define a method"
          ],
          "correct": 1,
          "explanation": "The 'final' keyword makes a variable constant, meaning its value cannot be changed after initialization."
        },
        {
          "question": "Which loop is best for iterating through an array when you need the index?",
          "options": [
            "for-each loop",
            "while loop",
            "traditional for loop",
            "do-while loop"
          ],
          "correct": 2,
          "explanation": "The traditional for loop with an index variable is best when you need to know the position of elements in an array."
        },
        {
          "question": "What is encapsulation in Java?",
          "options": [
            "Combining multiple classes into one",
            "Hiding data and methods within a class",
            "Creating multiple objects from a class",
            "Inheriting from another class"
          ],
          "correct": 1,
          "explanation": "Encapsulation is the bundling of data and methods that operate on that data within a single unit (class) and hiding the internal state."
        }
      ]
    }
  }
} 