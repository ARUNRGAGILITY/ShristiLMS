{
  "module": {
    "title": "Exception Handling and File I/O",
    "description": "Master exception handling, file operations, and input/output streams in Java",
    "lessons": [
      {
        "id": "java-4-1",
        "title": "Exception Handling Basics",
        "duration": "60 minutes",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Exception handling allows you to manage runtime errors gracefully. Java provides a robust exception handling mechanism using try-catch blocks."
            },
            {
              "type": "text",
              "content": "Exception handling is a critical aspect of robust Java programming that allows developers to manage and respond to runtime errors in a controlled manner. Instead of allowing programs to crash, exception handling provides a way to gracefully handle unexpected situations."
            },
            {
              "type": "text",
              "content": "Types of exceptions in Java:",
              "subsections": [
                "Checked Exceptions: Must be handled at compile time (IOException, SQLException)",
                "Unchecked Exceptions: Runtime exceptions that don't require explicit handling (NullPointerException, ArrayIndexOutOfBoundsException)",
                "Error: Serious problems that are not typically recoverable (OutOfMemoryError, StackOverflowError)"
              ]
            },
            {
              "type": "text",
              "content": "Exception handling components:",
              "subsections": [
                "try Block: Contains code that might throw an exception",
                "catch Block: Handles specific exceptions that occur in the try block",
                "finally Block: Always executes, regardless of whether an exception occurs",
                "throw Statement: Explicitly throws an exception",
                "throws Clause: Declares that a method may throw exceptions"
              ]
            },
            {
              "type": "text",
              "content": "Best practices for exception handling include catching specific exceptions rather than generic ones, avoiding empty catch blocks, and using try-with-resources for automatic resource management."
            },
            {
              "type": "code",
              "language": "java",
              "content": "public class ExceptionBasics {\n    public static void main(String[] args) {\n        // Basic try-catch\n        try {\n            int result = 10 / 0;\n        } catch (ArithmeticException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n        \n        // Multiple catch blocks\n        try {\n            String str = null;\n            System.out.println(str.length());\n        } catch (NullPointerException e) {\n            System.out.println(\"Null pointer error\");\n        } catch (Exception e) {\n            System.out.println(\"General error\");\n        }\n        \n        // Try-with-resources\n        try (ResourceManager resource = new ResourceManager()) {\n            resource.useResource();\n        } catch (Exception e) {\n            System.out.println(\"Resource error\");\n        }\n        \n        // Custom exception\n        try {\n            validateAge(-5);\n        } catch (InvalidAgeException e) {\n            System.out.println(\"Age error: \" + e.getMessage());\n        }\n    }\n    \n    public static void validateAge(int age) throws InvalidAgeException {\n        if (age < 0) {\n            throw new InvalidAgeException(\"Age cannot be negative\");\n        }\n    }\n}\n\nclass InvalidAgeException extends Exception {\n    public InvalidAgeException(String message) {\n        super(message);\n    }\n}\n\nclass ResourceManager implements AutoCloseable {\n    public void useResource() {\n        System.out.println(\"Using resource...\");\n    }\n    \n    @Override\n    public void close() {\n        System.out.println(\"Closing resource...\");\n    }\n}"
            },
            {
              "type": "text",
              "content": "Try-catch blocks handle exceptions, finally blocks ensure cleanup, and try-with-resources automatically manages resources. Custom exceptions can be created by extending Exception or RuntimeException."
            }
          ]
        }
      },
      {
        "id": "java-4-2",
        "title": "File Operations",
        "duration": "45 minutes",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Java provides comprehensive file handling capabilities through the java.io and java.nio packages. Understanding file operations is essential for data persistence."
            },
            {
              "type": "text",
              "content": "File operations are fundamental to most Java applications, enabling programs to read from and write to the file system. Java provides two main approaches: the traditional java.io package and the modern java.nio package introduced in Java 7."
            },
            {
              "type": "text",
              "content": "Key file operation concepts:",
              "subsections": [
                "File Creation: Creating new files and directories",
                "File Reading: Reading data from files in various formats",
                "File Writing: Writing data to files with proper error handling",
                "File Properties: Accessing metadata like size, modification date, permissions",
                "File Navigation: Traversing directory structures and listing contents"
              ]
            },
            {
              "type": "text",
              "content": "File handling approaches:",
              "subsections": [
                "java.io Package: Traditional approach with File class and various streams",
                "java.nio Package: Modern approach with Path, Files, and DirectoryStream",
                "Properties Files: Configuration files with key-value pairs",
                "Binary Files: Handling non-text files like images and executables",
                "Text Files: Reading and writing human-readable text files"
              ]
            },
            {
              "type": "text",
              "content": "Best practices for file operations include always using try-with-resources for automatic resource cleanup, checking file existence before operations, and handling potential security exceptions when accessing file system."
            },
            {
              "type": "code",
              "language": "java",
              "content": "import java.io.*;\nimport java.nio.file.*;\n\npublic class FileOperations {\n    public static void main(String[] args) {\n        // File creation\n        File file = new File(\"test.txt\");\n        \n        try {\n            if (file.createNewFile()) {\n                System.out.println(\"File created: \" + file.getName());\n            }\n            \n            System.out.println(\"File exists: \" + file.exists());\n            System.out.println(\"File size: \" + file.length() + \" bytes\");\n            \n        } catch (IOException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n        \n        // File writing\n        try (FileWriter writer = new FileWriter(\"test.txt\")) {\n            writer.write(\"Hello, this is a test file.\\n\");\n            writer.write(\"This is the second line.\");\n            System.out.println(\"Data written to file.\");\n        } catch (IOException e) {\n            System.out.println(\"Error writing: \" + e.getMessage());\n        }\n        \n        // File reading\n        try (FileReader reader = new FileReader(\"test.txt\")) {\n            BufferedReader bufferedReader = new BufferedReader(reader);\n            String line;\n            System.out.println(\"Reading file contents:\");\n            while ((line = bufferedReader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error reading: \" + e.getMessage());\n        }\n        \n        // File copying\n        try {\n            Files.copy(Paths.get(\"test.txt\"), Paths.get(\"test_copy.txt\"), \n                      StandardCopyOption.REPLACE_EXISTING);\n            System.out.println(\"File copied successfully.\");\n        } catch (IOException e) {\n            System.out.println(\"Error copying: \" + e.getMessage());\n        }\n    }\n}"
            },
            {
              "type": "text",
              "content": "File class provides basic file operations. FileWriter/FileReader handle text files. Properties class manages configuration files. Files utility class provides modern file operations."
            }
          ]
        }
      },
      {
        "id": "java-4-3",
        "title": "Input/Output Streams",
        "duration": "60 minutes",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Java I/O streams provide a way to read and write data. There are byte streams (InputStream/OutputStream) and character streams (Reader/Writer)."
            },
            {
              "type": "text",
              "content": "Java I/O streams form the foundation of data input and output operations, providing a unified way to read from and write to various data sources and destinations. Streams abstract the underlying data source, making it possible to use the same code for files, network connections, and memory buffers."
            },
            {
              "type": "text",
              "content": "Types of streams in Java:",
              "subsections": [
                "Byte Streams: Handle binary data using InputStream and OutputStream",
                "Character Streams: Handle text data using Reader and Writer",
                "Buffered Streams: Improve performance through internal buffering",
                "Data Streams: Handle primitive data types with DataInputStream/DataOutputStream",
                "Object Streams: Handle object serialization with ObjectInputStream/ObjectOutputStream"
              ]
            },
            {
              "type": "text",
              "content": "Common stream operations:",
              "subsections": [
                "Reading: Reading data from various sources (files, network, memory)",
                "Writing: Writing data to various destinations",
                "Buffering: Using buffered streams for improved performance",
                "Serialization: Converting objects to and from byte streams",
                "Filtering: Using filter streams for data transformation"
              ]
            },
            {
              "type": "text",
              "content": "Stream hierarchy and design patterns like decorator pattern allow for flexible composition of stream functionality. Always use try-with-resources to ensure proper stream cleanup."
            },
            {
              "type": "code",
              "language": "java",
              "content": "import java.io.*;\nimport java.util.*;\n\npublic class StreamOperations {\n    public static void main(String[] args) {\n        // Byte streams for binary data\n        try (FileOutputStream fos = new FileOutputStream(\"data.bin\")) {\n            byte[] data = {65, 66, 67, 68, 69}; // ABCDE\n            fos.write(data);\n            System.out.println(\"Binary data written to file.\");\n        } catch (IOException e) {\n            System.out.println(\"Error writing binary data: \" + e.getMessage());\n        }\n        \n        // Reading binary data\n        try (FileInputStream fis = new FileInputStream(\"data.bin\")) {\n            byte[] buffer = new byte[1024];\n            int bytesRead = fis.read(buffer);\n            System.out.println(\"\\nRead \" + bytesRead + \" bytes:\");\n            for (int i = 0; i < bytesRead; i++) {\n                System.out.print((char) buffer[i]);\n            }\n            System.out.println();\n        } catch (IOException e) {\n            System.out.println(\"Error reading binary data: \" + e.getMessage());\n        }\n        \n        // Buffered streams for better performance\n        try (BufferedWriter writer = new BufferedWriter(new FileWriter(\"buffered.txt\"))) {\n            writer.write(\"This is line 1\\n\");\n            writer.write(\"This is line 2\\n\");\n            writer.write(\"This is line 3\\n\");\n            System.out.println(\"\\nData written with BufferedWriter.\");\n        } catch (IOException e) {\n            System.out.println(\"Error writing with BufferedWriter: \" + e.getMessage());\n        }\n        \n        // Reading with BufferedReader\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"buffered.txt\"))) {\n            String line;\n            System.out.println(\"\\nReading with BufferedReader:\");\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error reading with BufferedReader: \" + e.getMessage());\n        }\n        \n        // Data streams for primitive types\n        try (DataOutputStream dos = new DataOutputStream(new FileOutputStream(\"data.dat\"))) {\n            dos.writeInt(42);\n            dos.writeDouble(3.14159);\n            dos.writeBoolean(true);\n            dos.writeUTF(\"Hello, DataStream!\");\n            System.out.println(\"\\nPrimitive data written to file.\");\n        } catch (IOException e) {\n            System.out.println(\"Error writing primitive data: \" + e.getMessage());\n        }\n        \n        // Reading primitive data\n        try (DataInputStream dis = new DataInputStream(new FileInputStream(\"data.dat\"))) {\n            int intValue = dis.readInt();\n            double doubleValue = dis.readDouble();\n            boolean boolValue = dis.readBoolean();\n            String stringValue = dis.readUTF();\n            \n            System.out.println(\"\\nRead primitive data:\");\n            System.out.println(\"Int: \" + intValue);\n            System.out.println(\"Double: \" + doubleValue);\n            System.out.println(\"Boolean: \" + boolValue);\n            System.out.println(\"String: \" + stringValue);\n        } catch (IOException e) {\n            System.out.println(\"Error reading primitive data: \" + e.getMessage());\n        }\n        \n        // Object serialization\n        Student student = new Student(\"Alice\", 20, \"Computer Science\");\n        \n        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"student.ser\"))) {\n            oos.writeObject(student);\n            System.out.println(\"\\nStudent object serialized.\");\n        } catch (IOException e) {\n            System.out.println(\"Error serializing object: \" + e.getMessage());\n        }\n        \n        // Object deserialization\n        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"student.ser\"))) {\n            Student loadedStudent = (Student) ois.readObject();\n            System.out.println(\"\\nDeserialized student: \" + loadedStudent);\n        } catch (IOException | ClassNotFoundException e) {\n            System.out.println(\"Error deserializing object: \" + e.getMessage());\n        }\n        \n        // Scanner for formatted input\n        try (PrintWriter pw = new PrintWriter(new FileWriter(\"numbers.txt\"))) {\n            pw.println(\"10 20 30 40 50\");\n            pw.println(\"1.5 2.5 3.5 4.5 5.5\");\n            System.out.println(\"\\nNumbers written to file.\");\n        } catch (IOException e) {\n            System.out.println(\"Error writing numbers: \" + e.getMessage());\n        }\n        \n        // Reading with Scanner\n        try (Scanner scanner = new Scanner(new File(\"numbers.txt\"))) {\n            System.out.println(\"\\nReading integers:\");\n            while (scanner.hasNextInt()) {\n                System.out.print(scanner.nextInt() + \" \");\n            }\n            \n            scanner.nextLine(); // Move to next line\n            \n            System.out.println(\"\\n\\nReading doubles:\");\n            while (scanner.hasNextDouble()) {\n                System.out.print(scanner.nextDouble() + \" \");\n            }\n            System.out.println();\n        } catch (IOException e) {\n            System.out.println(\"Error reading with Scanner: \" + e.getMessage());\n        }\n    }\n}\n\n// Serializable Student class\nclass Student implements Serializable {\n    private static final long serialVersionUID = 1L;\n    private String name;\n    private int age;\n    private String major;\n    \n    public Student(String name, int age, String major) {\n        this.name = name;\n        this.age = age;\n        this.major = major;\n    }\n    \n    @Override\n    public String toString() {\n        return \"Student{name='\" + name + \"', age=\" + age + \", major='\" + major + \"'}\";\n    }\n}"
            },
            {
              "type": "text",
              "content": "Byte streams handle binary data, character streams handle text. Buffered streams improve performance. Data streams handle primitive types. Object streams handle serialization."
            }
          ]
        }
      },
      {
        "id": "java-4-4",
        "title": "NIO.2 (Modern File Operations)",
        "duration": "45 minutes",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Java NIO.2 provides modern file operations with better performance and more features than traditional I/O. It includes Path, Files, and DirectoryStream classes."
            },
            {
              "type": "text",
              "content": "Java NIO.2 (New I/O 2) was introduced in Java 7 to provide a more modern and efficient approach to file system operations. It offers better performance, more intuitive APIs, and enhanced functionality compared to the traditional java.io package."
            },
            {
              "type": "text",
              "content": "Key NIO.2 components:",
              "subsections": [
                "Path Interface: Represents file and directory paths with cross-platform compatibility",
                "Files Utility Class: Provides static methods for common file operations",
                "DirectoryStream: Efficient iteration over directory contents",
                "File Attributes: Access to file metadata and properties",
                "File Watching: Monitoring file system changes in real-time"
              ]
            },
            {
              "type": "text",
              "content": "Advantages of NIO.2:",
              "subsections": [
                "Better Performance: More efficient file operations with reduced system calls",
                "Cross-Platform: Consistent behavior across different operating systems",
                "Enhanced Functionality: Support for symbolic links, file attributes, and watching",
                "Modern API: More intuitive and object-oriented design",
                "Asynchronous Operations: Support for non-blocking I/O operations"
              ]
            },
            {
              "type": "text",
              "content": "NIO.2 is particularly useful for applications that need to perform extensive file system operations, handle symbolic links, or monitor directory changes. It's the recommended approach for new Java applications."
            },
            {
              "type": "code",
              "language": "java",
              "content": "import java.nio.file.*;\nimport java.io.*;\n\npublic class NIO2Demo {\n    public static void main(String[] args) {\n        // Basic Path operations\n        Path path = Paths.get(\"test.txt\");\n        System.out.println(\"Path: \" + path);\n        System.out.println(\"File name: \" + path.getFileName());\n        \n        // Writing and reading files\n        try {\n            Files.write(path, \"Hello NIO.2!\".getBytes());\n            String content = Files.readString(path);\n            System.out.println(\"File content: \" + content);\n        } catch (IOException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n        \n        // Directory operations\n        Path dir = Paths.get(\"demo_dir\");\n        try {\n            Files.createDirectory(dir);\n            Path file = dir.resolve(\"demo.txt\");\n            Files.write(file, \"Demo content\".getBytes());\n            \n            // List directory contents\n            try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir)) {\n                for (Path entry : stream) {\n                    System.out.println(\"Found: \" + entry.getFileName());\n                }\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}"
            },
            {
              "type": "text",
              "content": "NIO.2 provides modern file operations with better performance. Path represents file/directory paths. Files utility class offers static methods for file operations. DirectoryStream allows efficient directory traversal."
            }
          ]
        }
      }
    ],
    "quiz": {
      "questions": [
        {
          "question": "What is the purpose of the finally block in exception handling?",
          "options": [
            "To catch exceptions",
            "To ensure cleanup code always executes",
            "To throw exceptions",
            "To create custom exceptions"
          ],
          "correct": 1,
          "explanation": "The finally block ensures that cleanup code executes regardless of whether an exception occurs or not."
        },
        {
          "question": "Which stream is used for reading binary data?",
          "options": [
            "FileReader",
            "FileInputStream",
            "BufferedReader",
            "DataInputStream"
          ],
          "correct": 1,
          "explanation": "FileInputStream is used for reading binary data, while FileReader is used for reading character data."
        },
        {
          "question": "What is the advantage of using Buffered streams?",
          "options": [
            "They are thread-safe",
            "They provide better performance through buffering",
            "They handle exceptions automatically",
            "They support serialization"
          ],
          "correct": 1,
          "explanation": "Buffered streams improve performance by reducing the number of system calls through internal buffering."
        },
        {
          "question": "Which NIO.2 class represents a file or directory path?",
          "options": [
            "File",
            "Path",
            "Files",
            "Directory"
          ],
          "correct": 1,
          "explanation": "The Path class in NIO.2 represents a file or directory path and provides methods for path manipulation."
        },
        {
          "question": "What is the purpose of the Serializable interface?",
          "options": [
            "To make objects thread-safe",
            "To allow objects to be written to and read from streams",
            "To provide file operations",
            "To handle exceptions"
          ],
          "correct": 1,
          "explanation": "The Serializable interface allows objects to be converted to a byte stream for storage or transmission."
        }
      ]
    }
  }
} 