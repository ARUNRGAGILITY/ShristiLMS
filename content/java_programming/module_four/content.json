{
  "module": {
    "title": "Exception Handling and File I/O",
    "description": "Master exception handling, file operations, and input/output streams in Java",
    "lessons": [
      {
        "id": "java-4-1",
        "title": "Exception Handling Basics",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Exception handling allows you to manage runtime errors gracefully. Java provides a robust exception handling mechanism using try-catch blocks."
            },
            {
              "type": "text",
              "content": "Exception handling is a critical aspect of robust Java programming that allows developers to manage and respond to runtime errors in a controlled manner. Instead of allowing programs to crash, exception handling provides a way to gracefully handle unexpected situations."
            },
            {
              "type": "text",
              "content": "Types of exceptions in Java:",
              "subsections": [
                "Checked Exceptions: Must be handled at compile time (IOException, SQLException)",
                "Unchecked Exceptions: Runtime exceptions that don't require explicit handling (NullPointerException, ArrayIndexOutOfBoundsException)",
                "Error: Serious problems that are not typically recoverable (OutOfMemoryError, StackOverflowError)"
              ]
            },
            {
              "type": "text",
              "content": "Exception handling components:",
              "subsections": [
                "try Block: Contains code that might throw an exception",
                "catch Block: Handles specific exceptions that occur in the try block",
                "finally Block: Always executes, regardless of whether an exception occurs",
                "throw Statement: Explicitly throws an exception",
                "throws Clause: Declares that a method may throw exceptions"
              ]
            },
            {
              "type": "text",
              "content": "Best practices for exception handling include catching specific exceptions rather than generic ones, avoiding empty catch blocks, and using try-with-resources for automatic resource management."
            },
            {
              "type": "code",
              "language": "java",
              "content": "public class ExceptionBasics {\n    public static void main(String[] args) {\n        // Basic try-catch block\n        try {\n            int result = divide(10, 0);\n            System.out.println(\"Result: \" + result);\n        } catch (ArithmeticException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n        \n        // Multiple catch blocks\n        try {\n            String str = null;\n            System.out.println(str.length());\n            \n            int[] numbers = {1, 2, 3};\n            System.out.println(numbers[5]);\n        } catch (NullPointerException e) {\n            System.out.println(\"Null pointer error: \" + e.getMessage());\n        } catch (ArrayIndexOutOfBoundsException e) {\n            System.out.println(\"Array index error: \" + e.getMessage());\n        } catch (Exception e) {\n            System.out.println(\"General error: \" + e.getMessage());\n        }\n        \n        // Try-catch with finally\n        try {\n            System.out.println(\"Opening resource...\");\n            // Simulate some operation\n            int result = 10 / 2;\n            System.out.println(\"Result: \" + result);\n        } catch (Exception e) {\n            System.out.println(\"Error occurred: \" + e.getMessage());\n        } finally {\n            System.out.println(\"Cleaning up resources...\");\n        }\n        \n        // Try-with-resources (Java 7+)\n        try (ResourceManager resource = new ResourceManager()) {\n            resource.useResource();\n        } catch (Exception e) {\n            System.out.println(\"Error with resource: \" + e.getMessage());\n        }\n        \n        // Custom exception\n        try {\n            validateAge(-5);\n        } catch (InvalidAgeException e) {\n            System.out.println(\"Age validation error: \" + e.getMessage());\n        }\n        \n        // Exception propagation\n        try {\n            methodA();\n        } catch (Exception e) {\n            System.out.println(\"Caught in main: \" + e.getMessage());\n        }\n    }\n    \n    public static int divide(int a, int b) {\n        return a / b; // This will throw ArithmeticException if b is 0\n    }\n    \n    public static void validateAge(int age) throws InvalidAgeException {\n        if (age < 0 || age > 150) {\n            throw new InvalidAgeException(\"Age must be between 0 and 150\");\n        }\n        System.out.println(\"Valid age: \" + age);\n    }\n    \n    public static void methodA() throws Exception {\n        methodB();\n    }\n    \n    public static void methodB() throws Exception {\n        throw new Exception(\"Exception from methodB\");\n    }\n}\n\n// Custom exception class\nclass InvalidAgeException extends Exception {\n    public InvalidAgeException(String message) {\n        super(message);\n    }\n}\n\n// Resource manager for try-with-resources\nclass ResourceManager implements AutoCloseable {\n    public void useResource() {\n        System.out.println(\"Using resource...\");\n    }\n    \n    @Override\n    public void close() {\n        System.out.println(\"Closing resource...\");\n    }\n}"
            },
            {
              "type": "text",
              "content": "Try-catch blocks handle exceptions, finally blocks ensure cleanup, and try-with-resources automatically manages resources. Custom exceptions can be created by extending Exception or RuntimeException."
            }
          ]
        }
      },
      {
        "id": "java-4-2",
        "title": "File Operations",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Java provides comprehensive file handling capabilities through the java.io and java.nio packages. Understanding file operations is essential for data persistence."
            },
            {
              "type": "text",
              "content": "File operations are fundamental to most Java applications, enabling programs to read from and write to the file system. Java provides two main approaches: the traditional java.io package and the modern java.nio package introduced in Java 7."
            },
            {
              "type": "text",
              "content": "Key file operation concepts:",
              "subsections": [
                "File Creation: Creating new files and directories",
                "File Reading: Reading data from files in various formats",
                "File Writing: Writing data to files with proper error handling",
                "File Properties: Accessing metadata like size, modification date, permissions",
                "File Navigation: Traversing directory structures and listing contents"
              ]
            },
            {
              "type": "text",
              "content": "File handling approaches:",
              "subsections": [
                "java.io Package: Traditional approach with File class and various streams",
                "java.nio Package: Modern approach with Path, Files, and DirectoryStream",
                "Properties Files: Configuration files with key-value pairs",
                "Binary Files: Handling non-text files like images and executables",
                "Text Files: Reading and writing human-readable text files"
              ]
            },
            {
              "type": "text",
              "content": "Best practices for file operations include always using try-with-resources for automatic resource cleanup, checking file existence before operations, and handling potential security exceptions when accessing file system."
            },
            {
              "type": "code",
              "language": "java",
              "content": "import java.io.*;\nimport java.nio.file.*;\nimport java.util.*;\n\npublic class FileOperations {\n    public static void main(String[] args) {\n        // File creation and basic operations\n        File file = new File(\"test.txt\");\n        \n        try {\n            if (file.createNewFile()) {\n                System.out.println(\"File created: \" + file.getName());\n            } else {\n                System.out.println(\"File already exists.\");\n            }\n            \n            System.out.println(\"File exists: \" + file.exists());\n            System.out.println(\"File size: \" + file.length() + \" bytes\");\n            System.out.println(\"Is file: \" + file.isFile());\n            System.out.println(\"Is directory: \" + file.isDirectory());\n            System.out.println(\"Can read: \" + file.canRead());\n            System.out.println(\"Can write: \" + file.canWrite());\n            \n        } catch (IOException e) {\n            System.out.println(\"Error creating file: \" + e.getMessage());\n        }\n        \n        // Directory operations\n        File directory = new File(\"testdir\");\n        if (directory.mkdir()) {\n            System.out.println(\"\\nDirectory created: \" + directory.getName());\n        }\n        \n        // List directory contents\n        File currentDir = new File(\".\");\n        File[] files = currentDir.listFiles();\n        \n        if (files != null) {\n            System.out.println(\"\\nCurrent directory contents:\");\n            for (File f : files) {\n                String type = f.isDirectory() ? \"[DIR]\" : \"[FILE]\";\n                System.out.println(type + \" \" + f.getName());\n            }\n        }\n        \n        // File writing with FileWriter\n        try (FileWriter writer = new FileWriter(\"test.txt\")) {\n            writer.write(\"Hello, this is a test file.\\n\");\n            writer.write(\"This is the second line.\\n\");\n            writer.write(\"And this is the third line.\");\n            System.out.println(\"\\nData written to file successfully.\");\n        } catch (IOException e) {\n            System.out.println(\"Error writing to file: \" + e.getMessage());\n        }\n        \n        // File reading with FileReader\n        try (FileReader reader = new FileReader(\"test.txt\")) {\n            BufferedReader bufferedReader = new BufferedReader(reader);\n            String line;\n            System.out.println(\"\\nReading file contents:\");\n            while ((line = bufferedReader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error reading file: \" + e.getMessage());\n        }\n        \n        // File copying\n        try {\n            Files.copy(Paths.get(\"test.txt\"), Paths.get(\"test_copy.txt\"), \n                      StandardCopyOption.REPLACE_EXISTING);\n            System.out.println(\"\\nFile copied successfully.\");\n        } catch (IOException e) {\n            System.out.println(\"Error copying file: \" + e.getMessage());\n        }\n        \n        // File deletion\n        File copyFile = new File(\"test_copy.txt\");\n        if (copyFile.delete()) {\n            System.out.println(\"\\nCopy file deleted successfully.\");\n        } else {\n            System.out.println(\"\\nFailed to delete copy file.\");\n        }\n        \n        // Properties file example\n        Properties props = new Properties();\n        props.setProperty(\"database.url\", \"jdbc:mysql://localhost:3306/test\");\n        props.setProperty(\"database.username\", \"admin\");\n        props.setProperty(\"database.password\", \"password123\");\n        \n        try (FileOutputStream out = new FileOutputStream(\"config.properties\")) {\n            props.store(out, \"Database Configuration\");\n            System.out.println(\"\\nProperties file created.\");\n        } catch (IOException e) {\n            System.out.println(\"Error writing properties: \" + e.getMessage());\n        }\n        \n        // Reading properties file\n        Properties loadedProps = new Properties();\n        try (FileInputStream in = new FileInputStream(\"config.properties\")) {\n            loadedProps.load(in);\n            System.out.println(\"\\nLoaded properties:\");\n            for (String key : loadedProps.stringPropertyNames()) {\n                System.out.println(key + \" = \" + loadedProps.getProperty(key));\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error reading properties: \" + e.getMessage());\n        }\n    }\n}"
            },
            {
              "type": "text",
              "content": "File class provides basic file operations. FileWriter/FileReader handle text files. Properties class manages configuration files. Files utility class provides modern file operations."
            }
          ]
        }
      },
      {
        "id": "java-4-3",
        "title": "Input/Output Streams",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Java I/O streams provide a way to read and write data. There are byte streams (InputStream/OutputStream) and character streams (Reader/Writer)."
            },
            {
              "type": "text",
              "content": "Java I/O streams form the foundation of data input and output operations, providing a unified way to read from and write to various data sources and destinations. Streams abstract the underlying data source, making it possible to use the same code for files, network connections, and memory buffers."
            },
            {
              "type": "text",
              "content": "Types of streams in Java:",
              "subsections": [
                "Byte Streams: Handle binary data using InputStream and OutputStream",
                "Character Streams: Handle text data using Reader and Writer",
                "Buffered Streams: Improve performance through internal buffering",
                "Data Streams: Handle primitive data types with DataInputStream/DataOutputStream",
                "Object Streams: Handle object serialization with ObjectInputStream/ObjectOutputStream"
              ]
            },
            {
              "type": "text",
              "content": "Common stream operations:",
              "subsections": [
                "Reading: Reading data from various sources (files, network, memory)",
                "Writing: Writing data to various destinations",
                "Buffering: Using buffered streams for improved performance",
                "Serialization: Converting objects to and from byte streams",
                "Filtering: Using filter streams for data transformation"
              ]
            },
            {
              "type": "text",
              "content": "Stream hierarchy and design patterns like decorator pattern allow for flexible composition of stream functionality. Always use try-with-resources to ensure proper stream cleanup."
            },
            {
              "type": "code",
              "language": "java",
              "content": "import java.io.*;\nimport java.util.*;\n\npublic class StreamOperations {\n    public static void main(String[] args) {\n        // Byte streams for binary data\n        try (FileOutputStream fos = new FileOutputStream(\"data.bin\")) {\n            byte[] data = {65, 66, 67, 68, 69}; // ABCDE\n            fos.write(data);\n            System.out.println(\"Binary data written to file.\");\n        } catch (IOException e) {\n            System.out.println(\"Error writing binary data: \" + e.getMessage());\n        }\n        \n        // Reading binary data\n        try (FileInputStream fis = new FileInputStream(\"data.bin\")) {\n            byte[] buffer = new byte[1024];\n            int bytesRead = fis.read(buffer);\n            System.out.println(\"\\nRead \" + bytesRead + \" bytes:\");\n            for (int i = 0; i < bytesRead; i++) {\n                System.out.print((char) buffer[i]);\n            }\n            System.out.println();\n        } catch (IOException e) {\n            System.out.println(\"Error reading binary data: \" + e.getMessage());\n        }\n        \n        // Buffered streams for better performance\n        try (BufferedWriter writer = new BufferedWriter(new FileWriter(\"buffered.txt\"))) {\n            writer.write(\"This is line 1\\n\");\n            writer.write(\"This is line 2\\n\");\n            writer.write(\"This is line 3\\n\");\n            System.out.println(\"\\nData written with BufferedWriter.\");\n        } catch (IOException e) {\n            System.out.println(\"Error writing with BufferedWriter: \" + e.getMessage());\n        }\n        \n        // Reading with BufferedReader\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"buffered.txt\"))) {\n            String line;\n            System.out.println(\"\\nReading with BufferedReader:\");\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error reading with BufferedReader: \" + e.getMessage());\n        }\n        \n        // Data streams for primitive types\n        try (DataOutputStream dos = new DataOutputStream(new FileOutputStream(\"data.dat\"))) {\n            dos.writeInt(42);\n            dos.writeDouble(3.14159);\n            dos.writeBoolean(true);\n            dos.writeUTF(\"Hello, DataStream!\");\n            System.out.println(\"\\nPrimitive data written to file.\");\n        } catch (IOException e) {\n            System.out.println(\"Error writing primitive data: \" + e.getMessage());\n        }\n        \n        // Reading primitive data\n        try (DataInputStream dis = new DataInputStream(new FileInputStream(\"data.dat\"))) {\n            int intValue = dis.readInt();\n            double doubleValue = dis.readDouble();\n            boolean boolValue = dis.readBoolean();\n            String stringValue = dis.readUTF();\n            \n            System.out.println(\"\\nRead primitive data:\");\n            System.out.println(\"Int: \" + intValue);\n            System.out.println(\"Double: \" + doubleValue);\n            System.out.println(\"Boolean: \" + boolValue);\n            System.out.println(\"String: \" + stringValue);\n        } catch (IOException e) {\n            System.out.println(\"Error reading primitive data: \" + e.getMessage());\n        }\n        \n        // Object serialization\n        Student student = new Student(\"Alice\", 20, \"Computer Science\");\n        \n        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"student.ser\"))) {\n            oos.writeObject(student);\n            System.out.println(\"\\nStudent object serialized.\");\n        } catch (IOException e) {\n            System.out.println(\"Error serializing object: \" + e.getMessage());\n        }\n        \n        // Object deserialization\n        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"student.ser\"))) {\n            Student loadedStudent = (Student) ois.readObject();\n            System.out.println(\"\\nDeserialized student: \" + loadedStudent);\n        } catch (IOException | ClassNotFoundException e) {\n            System.out.println(\"Error deserializing object: \" + e.getMessage());\n        }\n        \n        // Scanner for formatted input\n        try (PrintWriter pw = new PrintWriter(new FileWriter(\"numbers.txt\"))) {\n            pw.println(\"10 20 30 40 50\");\n            pw.println(\"1.5 2.5 3.5 4.5 5.5\");\n            System.out.println(\"\\nNumbers written to file.\");\n        } catch (IOException e) {\n            System.out.println(\"Error writing numbers: \" + e.getMessage());\n        }\n        \n        // Reading with Scanner\n        try (Scanner scanner = new Scanner(new File(\"numbers.txt\"))) {\n            System.out.println(\"\\nReading integers:\");\n            while (scanner.hasNextInt()) {\n                System.out.print(scanner.nextInt() + \" \");\n            }\n            \n            scanner.nextLine(); // Move to next line\n            \n            System.out.println(\"\\n\\nReading doubles:\");\n            while (scanner.hasNextDouble()) {\n                System.out.print(scanner.nextDouble() + \" \");\n            }\n            System.out.println();\n        } catch (IOException e) {\n            System.out.println(\"Error reading with Scanner: \" + e.getMessage());\n        }\n    }\n}\n\n// Serializable Student class\nclass Student implements Serializable {\n    private static final long serialVersionUID = 1L;\n    private String name;\n    private int age;\n    private String major;\n    \n    public Student(String name, int age, String major) {\n        this.name = name;\n        this.age = age;\n        this.major = major;\n    }\n    \n    @Override\n    public String toString() {\n        return \"Student{name='\" + name + \"', age=\" + age + \", major='\" + major + \"'}\";\n    }\n}"
            },
            {
              "type": "text",
              "content": "Byte streams handle binary data, character streams handle text. Buffered streams improve performance. Data streams handle primitive types. Object streams handle serialization."
            }
          ]
        }
      },
      {
        "id": "java-4-4",
        "title": "NIO.2 (Modern File Operations)",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Java NIO.2 provides modern file operations with better performance and more features than traditional I/O. It includes Path, Files, and DirectoryStream classes."
            },
            {
              "type": "text",
              "content": "Java NIO.2 (New I/O 2) was introduced in Java 7 to provide a more modern and efficient approach to file system operations. It offers better performance, more intuitive APIs, and enhanced functionality compared to the traditional java.io package."
            },
            {
              "type": "text",
              "content": "Key NIO.2 components:",
              "subsections": [
                "Path Interface: Represents file and directory paths with cross-platform compatibility",
                "Files Utility Class: Provides static methods for common file operations",
                "DirectoryStream: Efficient iteration over directory contents",
                "File Attributes: Access to file metadata and properties",
                "File Watching: Monitoring file system changes in real-time"
              ]
            },
            {
              "type": "text",
              "content": "Advantages of NIO.2:",
              "subsections": [
                "Better Performance: More efficient file operations with reduced system calls",
                "Cross-Platform: Consistent behavior across different operating systems",
                "Enhanced Functionality: Support for symbolic links, file attributes, and watching",
                "Modern API: More intuitive and object-oriented design",
                "Asynchronous Operations: Support for non-blocking I/O operations"
              ]
            },
            {
              "type": "text",
              "content": "NIO.2 is particularly useful for applications that need to perform extensive file system operations, handle symbolic links, or monitor directory changes. It's the recommended approach for new Java applications."
            },
            {
              "type": "code",
              "language": "java",
              "content": "import java.nio.file.*;\nimport java.nio.charset.*;\nimport java.io.*;\nimport java.util.stream.*;\n\npublic class NIO2Operations {\n    public static void main(String[] args) {\n        // Path operations\n        Path path = Paths.get(\"nio2_test.txt\");\n        \n        System.out.println(\"Path: \" + path);\n        System.out.println(\"File name: \" + path.getFileName());\n        System.out.println(\"Parent: \" + path.getParent());\n        System.out.println(\"Root: \" + path.getRoot());\n        System.out.println(\"Is absolute: \" + path.isAbsolute());\n        \n        // Creating and writing files\n        try {\n            Files.write(path, \"Hello NIO.2!\\nThis is a test file.\".getBytes());\n            System.out.println(\"\\nFile written using NIO.2\");\n        } catch (IOException e) {\n            System.out.println(\"Error writing file: \" + e.getMessage());\n        }\n        \n        // Reading files\n        try {\n            String content = Files.readString(path);\n            System.out.println(\"\\nFile content:\");\n            System.out.println(content);\n        } catch (IOException e) {\n            System.out.println(\"Error reading file: \" + e.getMessage());\n        }\n        \n        // Reading lines\n        try {\n            List<String> lines = Files.readAllLines(path);\n            System.out.println(\"\\nLines in file:\");\n            for (int i = 0; i < lines.size(); i++) {\n                System.out.println(\"Line \" + (i + 1) + \": \" + lines.get(i));\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error reading lines: \" + e.getMessage());\n        }\n        \n        // File attributes\n        try {\n            BasicFileAttributes attrs = Files.readAttributes(path, BasicFileAttributes.class);\n            System.out.println(\"\\nFile attributes:\");\n            System.out.println(\"Size: \" + attrs.size() + \" bytes\");\n            System.out.println(\"Created: \" + attrs.creationTime());\n            System.out.println(\"Modified: \" + attrs.lastModifiedTime());\n            System.out.println(\"Is directory: \" + attrs.isDirectory());\n            System.out.println(\"Is regular file: \" + attrs.isRegularFile());\n        } catch (IOException e) {\n            System.out.println(\"Error reading attributes: \" + e.getMessage());\n        }\n        \n        // Directory operations\n        Path dir = Paths.get(\"nio2_directory\");\n        try {\n            Files.createDirectory(dir);\n            System.out.println(\"\\nDirectory created: \" + dir);\n        } catch (FileAlreadyExistsException e) {\n            System.out.println(\"Directory already exists.\");\n        } catch (IOException e) {\n            System.out.println(\"Error creating directory: \" + e.getMessage());\n        }\n        \n        // Creating files in directory\n        Path file1 = dir.resolve(\"file1.txt\");\n        Path file2 = dir.resolve(\"file2.txt\");\n        \n        try {\n            Files.write(file1, \"Content of file 1\".getBytes());\n            Files.write(file2, \"Content of file 2\".getBytes());\n            System.out.println(\"\\nFiles created in directory.\");\n        } catch (IOException e) {\n            System.out.println(\"Error creating files: \" + e.getMessage());\n        }\n        \n        // Listing directory contents\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir)) {\n            System.out.println(\"\\nDirectory contents:\");\n            for (Path entry : stream) {\n                System.out.println(entry.getFileName());\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error listing directory: \" + e.getMessage());\n        }\n        \n        // Walking directory tree\n        try (Stream<Path> walk = Files.walk(dir)) {\n            System.out.println(\"\\nWalking directory tree:\");\n            walk.forEach(System.out::println);\n        } catch (IOException e) {\n            System.out.println(\"Error walking directory: \" + e.getMessage());\n        }\n        \n        // File copying and moving\n        Path source = file1;\n        Path target = dir.resolve(\"file1_copy.txt\");\n        \n        try {\n            Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);\n            System.out.println(\"\\nFile copied successfully.\");\n        } catch (IOException e) {\n            System.out.println(\"Error copying file: \" + e.getMessage());\n        }\n        \n        // Moving file\n        Path moveTarget = dir.resolve(\"file1_moved.txt\");\n        try {\n            Files.move(target, moveTarget, StandardCopyOption.REPLACE_EXISTING);\n            System.out.println(\"\\nFile moved successfully.\");\n        } catch (IOException e) {\n            System.out.println(\"Error moving file: \" + e.getMessage());\n        }\n        \n        // Temporary files\n        try {\n            Path tempFile = Files.createTempFile(\"temp\", \".txt\");\n            System.out.println(\"\\nTemporary file created: \" + tempFile);\n            \n            Files.write(tempFile, \"Temporary content\".getBytes());\n            \n            // Clean up temp file\n            Files.delete(tempFile);\n            System.out.println(\"Temporary file deleted.\");\n        } catch (IOException e) {\n            System.out.println(\"Error with temporary file: \" + e.getMessage());\n        }\n        \n        // File watching (simplified)\n        try {\n            WatchService watchService = FileSystems.getDefault().newWatchService();\n            dir.register(watchService, StandardWatchEventKinds.ENTRY_CREATE, \n                        StandardWatchEventKinds.ENTRY_DELETE, \n                        StandardWatchEventKinds.ENTRY_MODIFY);\n            \n            System.out.println(\"\\nWatching directory for changes... (will timeout after 5 seconds)\");\n            \n            // Watch for 5 seconds\n            long startTime = System.currentTimeMillis();\n            while (System.currentTimeMillis() - startTime < 5000) {\n                WatchKey key = watchService.poll();\n                if (key != null) {\n                    for (WatchEvent<?> event : key.pollEvents()) {\n                        System.out.println(\"Event: \" + event.kind() + \" - \" + event.context());\n                    }\n                    key.reset();\n                }\n            }\n            watchService.close();\n        } catch (IOException e) {\n            System.out.println(\"Error setting up file watching: \" + e.getMessage());\n        }\n        \n        // Cleanup\n        try {\n            Files.walk(dir)\n                 .sorted((p1, p2) -> p2.compareTo(p1)) // Delete files before directories\n                 .forEach(p -> {\n                     try {\n                         Files.delete(p);\n                         System.out.println(\"Deleted: \" + p);\n                     } catch (IOException e) {\n                         System.out.println(\"Error deleting: \" + p);\n                     }\n                 });\n            Files.delete(dir);\n            System.out.println(\"\\nCleanup completed.\");\n        } catch (IOException e) {\n            System.out.println(\"Error during cleanup: \" + e.getMessage());\n        }\n    }\n}"
            },
            {
              "type": "text",
              "content": "NIO.2 provides modern file operations with better performance. Path represents file/directory paths. Files utility class offers static methods for file operations. DirectoryStream allows efficient directory traversal."
            }
          ]
        }
      }
    ],
    "quiz": {
      "questions": [
        {
          "question": "What is the purpose of the finally block in exception handling?",
          "options": [
            "To catch exceptions",
            "To ensure cleanup code always executes",
            "To throw exceptions",
            "To create custom exceptions"
          ],
          "correct": 1,
          "explanation": "The finally block ensures that cleanup code executes regardless of whether an exception occurs or not."
        },
        {
          "question": "Which stream is used for reading binary data?",
          "options": [
            "FileReader",
            "FileInputStream",
            "BufferedReader",
            "DataInputStream"
          ],
          "correct": 1,
          "explanation": "FileInputStream is used for reading binary data, while FileReader is used for reading character data."
        },
        {
          "question": "What is the advantage of using Buffered streams?",
          "options": [
            "They are thread-safe",
            "They provide better performance through buffering",
            "They handle exceptions automatically",
            "They support serialization"
          ],
          "correct": 1,
          "explanation": "Buffered streams improve performance by reducing the number of system calls through internal buffering."
        },
        {
          "question": "Which NIO.2 class represents a file or directory path?",
          "options": [
            "File",
            "Path",
            "Files",
            "Directory"
          ],
          "correct": 1,
          "explanation": "The Path class in NIO.2 represents a file or directory path and provides methods for path manipulation."
        },
        {
          "question": "What is the purpose of the Serializable interface?",
          "options": [
            "To make objects thread-safe",
            "To allow objects to be written to and read from streams",
            "To provide file operations",
            "To handle exceptions"
          ],
          "correct": 1,
          "explanation": "The Serializable interface allows objects to be converted to a byte stream for storage or transmission."
        }
      ]
    }
  }
} 