{
  "module": {
    "title": "Object-Oriented Programming",
    "description": "Master inheritance, polymorphism, abstraction, and encapsulation in Java",
    "lessons": [
      {
        "id": "java-2-1",
        "title": "Inheritance",
        "duration": "45 minutes",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Inheritance is a fundamental concept in object-oriented programming that allows a class to inherit properties and methods from another class. This promotes code reuse and establishes a hierarchical relationship between classes."
            },
            {
              "type": "text",
              "content": "Inheritance is one of the four pillars of Object-Oriented Programming (OOP), along with encapsulation, polymorphism, and abstraction. It enables you to create a new class that is based on an existing class, inheriting all its properties and methods while adding new ones or overriding existing ones."
            },
            {
              "type": "text",
              "content": "Key concepts of inheritance:",
              "subsections": [
                "Base Class (Parent/Superclass): The class being inherited from",
                "Derived Class (Child/Subclass): The class that inherits from the base class",
                "Code Reuse: Subclasses can use methods and properties from the parent class",
                "Method Overriding: Subclasses can provide their own implementation of inherited methods",
                "Single Inheritance: Java supports single inheritance (one parent class per child class)"
              ]
            },
            {
              "type": "text",
              "content": "Benefits of inheritance include code reuse, establishing relationships between classes, and supporting polymorphism. The 'extends' keyword is used to create inheritance relationships, and 'super()' is used to call the parent class constructor."
            },
            {
              "type": "code",
              "language": "java",
              "content": "public class Animal {\n    protected String name;\n    protected int age;\n    \n    public Animal(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    public void eat() {\n        System.out.println(name + \" is eating.\");\n    }\n    \n    public void makeSound() {\n        System.out.println(name + \" makes a sound.\");\n    }\n}\n\npublic class Dog extends Animal {\n    private String breed;\n    \n    public Dog(String name, int age, String breed) {\n        super(name, age);\n        this.breed = breed;\n    }\n    \n    @Override\n    public void makeSound() {\n        System.out.println(name + \" barks: Woof!\");\n    }\n    \n    public void fetch() {\n        System.out.println(name + \" is fetching the ball.\");\n    }\n}\n\npublic class InheritanceDemo {\n    public static void main(String[] args) {\n        Animal animal = new Animal(\"Generic Animal\", 5);\n        Dog dog = new Dog(\"Buddy\", 3, \"Golden Retriever\");\n        \n        animal.eat();\n        animal.makeSound();\n        \n        dog.eat(); // Inherited method\n        dog.makeSound(); // Overridden method\n        dog.fetch(); // Dog-specific method\n    }\n}"
            },
            {
              "type": "text",
              "content": "Inheritance allows code reuse and establishes an 'is-a' relationship. The 'extends' keyword is used to inherit from a parent class, and 'super()' is used to call the parent constructor."
            }
          ]
        }
      },
      {
        "id": "java-2-2",
        "title": "Polymorphism",
        "duration": "45 minutes",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Polymorphism allows objects of different classes to be treated as objects of a common superclass. It enables flexibility and extensibility in object-oriented design."
            },
            {
              "type": "text",
              "content": "Polymorphism, derived from Greek words meaning 'many forms,' is a core concept in object-oriented programming that allows objects to take on multiple forms. It enables you to write code that can work with objects of different types through a common interface."
            },
            {
              "type": "text",
              "content": "Types of polymorphism in Java:",
              "subsections": [
                "Runtime Polymorphism (Method Overriding): When a subclass provides a specific implementation of a method that is already defined in its parent class",
                "Compile-time Polymorphism (Method Overloading): When multiple methods have the same name but different parameters",
                "Interface Polymorphism: When objects implement interfaces and can be treated as the interface type"
              ]
            },
            {
              "type": "text",
              "content": "Polymorphism provides several advantages including code flexibility, extensibility, and the ability to write more generic code. It's essential for creating maintainable and scalable applications."
            },
            {
              "type": "code",
              "language": "java",
              "content": "public abstract class Shape {\n    protected String color;\n    \n    public Shape(String color) {\n        this.color = color;\n    }\n    \n    public abstract double calculateArea();\n    \n    public String getColor() {\n        return color;\n    }\n}\n\npublic class Circle extends Shape {\n    private double radius;\n    \n    public Circle(String color, double radius) {\n        super(color);\n        this.radius = radius;\n    }\n    \n    @Override\n    public double calculateArea() {\n        return Math.PI * radius * radius;\n    }\n}\n\npublic class Rectangle extends Shape {\n    private double width;\n    private double height;\n    \n    public Rectangle(String color, double width, double height) {\n        super(color);\n        this.width = width;\n        this.height = height;\n    }\n    \n    @Override\n    public double calculateArea() {\n        return width * height;\n    }\n}\n\npublic class PolymorphismDemo {\n    public static void main(String[] args) {\n        Shape circle = new Circle(\"Red\", 5.0);\n        Shape rectangle = new Rectangle(\"Blue\", 4.0, 6.0);\n        \n        System.out.println(\"Circle area: \" + circle.calculateArea());\n        System.out.println(\"Rectangle area: \" + rectangle.calculateArea());\n        \n        // Polymorphic array\n        Shape[] shapes = {circle, rectangle};\n        for (Shape shape : shapes) {\n            System.out.println(\"Area: \" + shape.calculateArea());\n        }\n    }\n}"
            },
            {
              "type": "text",
              "content": "Polymorphism comes in two forms: runtime polymorphism (method overriding) and compile-time polymorphism (method overloading). It allows for flexible and extensible code design."
            }
          ]
        }
      },
      {
        "id": "java-2-3",
        "title": "Abstraction",
        "duration": "45 minutes",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Abstraction is the process of hiding complex implementation details and showing only the necessary features. In Java, this is achieved through abstract classes and interfaces."
            },
            {
              "type": "text",
              "content": "Abstraction is a fundamental principle of object-oriented programming that helps manage complexity by hiding unnecessary details and exposing only what is essential. It allows developers to focus on what an object does rather than how it does it."
            },
            {
              "type": "text",
              "content": "Abstraction in Java is implemented through:",
              "subsections": [
                "Abstract Classes: Classes that cannot be instantiated and may contain abstract methods",
                "Interfaces: Pure abstraction that defines a contract for implementing classes",
                "Abstract Methods: Methods declared without implementation that must be implemented by subclasses",
                "Concrete Methods: Methods with complete implementation that can be inherited"
              ]
            },
            {
              "type": "text",
              "content": "Benefits of abstraction include simplified code, better organization, and the ability to change implementation details without affecting the rest of the system. It promotes loose coupling and high cohesion in software design."
            },
            {
              "type": "code",
              "language": "java",
              "content": "public abstract class BankAccount {\n    protected String accountNumber;\n    protected double balance;\n    \n    public BankAccount(String accountNumber, double initialBalance) {\n        this.accountNumber = accountNumber;\n        this.balance = initialBalance;\n    }\n    \n    public abstract void deposit(double amount);\n    public abstract void withdraw(double amount);\n    \n    public double getBalance() {\n        return balance;\n    }\n}\n\npublic class SavingsAccount extends BankAccount {\n    public SavingsAccount(String accountNumber, double initialBalance) {\n        super(accountNumber, initialBalance);\n    }\n    \n    @Override\n    public void deposit(double amount) {\n        if (amount > 0) {\n            balance += amount;\n            System.out.println(\"Deposited: $\" + amount);\n        }\n    }\n    \n    @Override\n    public void withdraw(double amount) {\n        if (amount > 0 && amount <= balance) {\n            balance -= amount;\n            System.out.println(\"Withdrawn: $\" + amount);\n        }\n    }\n}\n\npublic interface Payable {\n    double calculatePayment();\n}\n\npublic class Employee implements Payable {\n    private String name;\n    private double hourlyRate;\n    \n    public Employee(String name, double hourlyRate) {\n        this.name = name;\n        this.hourlyRate = hourlyRate;\n    }\n    \n    @Override\n    public double calculatePayment() {\n        return hourlyRate * 40; // 40 hours\n    }\n}\n\npublic class AbstractionDemo {\n    public static void main(String[] args) {\n        BankAccount savings = new SavingsAccount(\"SA001\", 1000.0);\n        savings.deposit(500.0);\n        savings.withdraw(200.0);\n        \n        Employee emp = new Employee(\"John\", 25.0);\n        System.out.println(\"Payment: $\" + emp.calculatePayment());\n    }\n}"
            },
            {
              "type": "text",
              "content": "Abstraction helps manage complexity by hiding implementation details. Abstract classes can have both abstract and concrete methods, while interfaces define contracts that implementing classes must fulfill."
            }
          ]
        }
      },
      {
        "id": "java-2-4",
        "title": "Encapsulation",
        "duration": "30 minutes",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Encapsulation is the bundling of data and methods that operate on that data within a single unit (class) and hiding the internal state. It's achieved through access modifiers and getter/setter methods."
            },
            {
              "type": "text",
              "content": "Encapsulation is a fundamental principle of object-oriented programming that combines data and the methods that operate on that data into a single unit, while hiding the internal implementation details from the outside world."
            },
            {
              "type": "text",
              "content": "Key components of encapsulation:",
              "subsections": [
                "Data Hiding: Making fields private to prevent direct access from outside the class",
                "Access Modifiers: Using private, protected, and public to control access levels",
                "Getter Methods: Public methods that provide read access to private fields",
                "Setter Methods: Public methods that provide write access to private fields with validation",
                "Business Logic: Methods that implement the class's behavior and rules"
              ]
            },
            {
              "type": "text",
              "content": "Encapsulation provides several benefits including data security, code maintainability, and the ability to change internal implementation without affecting external code. It's essential for creating robust and secure applications."
            },
            {
              "type": "code",
              "language": "java",
              "content": "public class Student {\n    private String name;\n    private int studentId;\n    private double gpa;\n    \n    public Student(String name, int studentId) {\n        this.name = name;\n        this.studentId = studentId;\n        this.gpa = 0.0;\n    }\n    \n    // Getter methods\n    public String getName() {\n        return name;\n    }\n    \n    public double getGpa() {\n        return gpa;\n    }\n    \n    // Setter methods with validation\n    public void setGpa(double gpa) {\n        if (gpa >= 0.0 && gpa <= 4.0) {\n            this.gpa = gpa;\n        }\n    }\n    \n    public void addGrade(double grade) {\n        if (grade >= 0.0 && grade <= 4.0) {\n            gpa = (gpa + grade) / 2.0;\n        }\n    }\n}\n\npublic class EncapsulationDemo {\n    public static void main(String[] args) {\n        Student student = new Student(\"Alice\", 12345);\n        \n        student.setGpa(3.8);\n        student.addGrade(4.0);\n        \n        System.out.println(\"Name: \" + student.getName());\n        System.out.println(\"GPA: \" + student.getGpa());\n    }\n}"
            },
            {
              "type": "text",
              "content": "Encapsulation provides data hiding and protection through access modifiers (private, protected, public). Getter and setter methods control access to private fields, allowing validation and business logic."
            }
          ]
        }
      },
      {
        "id": "java-2-5",
        "title": "Interfaces",
        "duration": "45 minutes",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Interfaces in Java define a contract that implementing classes must follow. They provide a way to achieve multiple inheritance and define common behavior across different classes."
            },
            {
              "type": "text",
              "content": "Interfaces are a powerful feature in Java that provide a way to achieve abstraction and define a contract that classes must implement. They serve as a blueprint for classes, specifying what methods must be implemented without providing the implementation details."
            },
            {
              "type": "text",
              "content": "Key characteristics of interfaces:",
              "subsections": [
                "Contract Definition: Interfaces define what methods implementing classes must provide",
                "Multiple Implementation: A class can implement multiple interfaces",
                "Pure Abstraction: Interfaces contain only method signatures (before Java 8)",
                "Default Methods: Java 8+ allows interfaces to have default method implementations",
                "Static Methods: Interfaces can contain static methods (Java 8+)",
                "Constants: Interfaces can contain public static final constants"
              ]
            },
            {
              "type": "text",
              "content": "Interfaces provide several advantages including loose coupling, support for multiple inheritance, and the ability to create pluggable components. They are essential for creating flexible and extensible software architectures."
            },
            {
              "type": "code",
              "language": "java",
              "content": "public interface Vehicle {\n    void start();\n    void stop();\n    String getVehicleType();\n}\n\npublic interface ElectricVehicle {\n    void charge();\n    double getBatteryLevel();\n}\n\npublic class Car implements Vehicle {\n    private String brand;\n    private String model;\n    \n    public Car(String brand, String model) {\n        this.brand = brand;\n        this.model = model;\n    }\n    \n    @Override\n    public void start() {\n        System.out.println(brand + \" \" + model + \" started.\");\n    }\n    \n    @Override\n    public void stop() {\n        System.out.println(brand + \" \" + model + \" stopped.\");\n    }\n    \n    @Override\n    public String getVehicleType() {\n        return \"Car\";\n    }\n}\n\npublic class ElectricCar implements Vehicle, ElectricVehicle {\n    private String brand;\n    private String model;\n    private double batteryLevel;\n    \n    public ElectricCar(String brand, String model) {\n        this.brand = brand;\n        this.model = model;\n        this.batteryLevel = 100.0;\n    }\n    \n    @Override\n    public void start() {\n        System.out.println(brand + \" \" + model + \" (Electric) started.\");\n    }\n    \n    @Override\n    public void stop() {\n        System.out.println(brand + \" \" + model + \" stopped.\");\n    }\n    \n    @Override\n    public String getVehicleType() {\n        return \"Electric Car\";\n    }\n    \n    @Override\n    public void charge() {\n        batteryLevel = 100.0;\n        System.out.println(\"Charging... Battery level: \" + batteryLevel + \"%\");\n    }\n    \n    @Override\n    public double getBatteryLevel() {\n        return batteryLevel;\n    }\n}\n\npublic class InterfaceDemo {\n    public static void main(String[] args) {\n        Vehicle car = new Car(\"Toyota\", \"Camry\");\n        Vehicle electricCar = new ElectricCar(\"Tesla\", \"Model 3\");\n        \n        car.start();\n        car.stop();\n        \n        electricCar.start();\n        electricCar.stop();\n        \n        ElectricCar tesla = (ElectricCar) electricCar;\n        tesla.charge();\n        System.out.println(\"Battery level: \" + tesla.getBatteryLevel() + \"%\");\n    }\n}"
            },
            {
              "type": "text",
              "content": "Interfaces provide a way to define common behavior across different classes. A class can implement multiple interfaces, achieving a form of multiple inheritance. Interfaces help create loosely coupled, extensible code."
            }
          ]
        }
      }
    ],
    "quiz": {
      "questions": [
        {
          "question": "What is inheritance in Java?",
          "options": [
            "A way to create multiple objects from a class",
            "A mechanism that allows a class to inherit properties and methods from another class",
            "A way to hide data within a class",
            "A method to create abstract classes"
          ],
          "correct": 1,
          "explanation": "Inheritance allows a class to inherit properties and methods from a parent class, promoting code reuse and establishing hierarchical relationships."
        },
        {
          "question": "Which keyword is used to inherit from a parent class?",
          "options": [
            "implements",
            "extends",
            "inherits",
            "super"
          ],
          "correct": 1,
          "explanation": "The 'extends' keyword is used to inherit from a parent class in Java."
        },
        {
          "question": "What is polymorphism?",
          "options": [
            "The ability to create multiple objects",
            "The ability of different objects to respond to the same method call in different ways",
            "The process of hiding implementation details",
            "The bundling of data and methods"
          ],
          "correct": 1,
          "explanation": "Polymorphism allows objects of different classes to be treated as objects of a common superclass and respond to method calls differently."
        },
        {
          "question": "What is the purpose of the 'abstract' keyword?",
          "options": [
            "To create a final class",
            "To create a class that cannot be instantiated and may contain abstract methods",
            "To create a private class",
            "To create a static class"
          ],
          "correct": 1,
          "explanation": "The 'abstract' keyword creates a class that cannot be instantiated and may contain abstract methods that must be implemented by subclasses."
        },
        {
          "question": "What is encapsulation?",
          "options": [
            "The process of creating multiple classes",
            "The bundling of data and methods that operate on that data within a single unit",
            "The process of inheriting from multiple classes",
            "The creation of abstract methods"
          ],
          "correct": 1,
          "explanation": "Encapsulation is the bundling of data and methods that operate on that data within a single unit (class) and hiding the internal state."
        }
      ]
    }
  }
} 