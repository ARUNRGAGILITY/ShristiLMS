{
  "module": {
    "title": "Object-Oriented Programming",
    "description": "Master inheritance, polymorphism, abstraction, and encapsulation in Java",
    "lessons": [
      {
        "id": "java-2-1",
        "title": "Inheritance",
        "duration": "45 minutes",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Inheritance is a fundamental concept in object-oriented programming that allows a class to inherit properties and methods from another class. This promotes code reuse and establishes a hierarchical relationship between classes."
            },
            {
              "type": "text",
              "content": "Inheritance is one of the four pillars of Object-Oriented Programming (OOP), along with encapsulation, polymorphism, and abstraction. It enables you to create a new class that is based on an existing class, inheriting all its properties and methods while adding new ones or overriding existing ones."
            },
            {
              "type": "text",
              "content": "Key concepts of inheritance:",
              "subsections": [
                "Base Class (Parent/Superclass): The class being inherited from",
                "Derived Class (Child/Subclass): The class that inherits from the base class",
                "Code Reuse: Subclasses can use methods and properties from the parent class",
                "Method Overriding: Subclasses can provide their own implementation of inherited methods",
                "Single Inheritance: Java supports single inheritance (one parent class per child class)"
              ]
            },
            {
              "type": "text",
              "content": "Benefits of inheritance include code reuse, establishing relationships between classes, and supporting polymorphism. The 'extends' keyword is used to create inheritance relationships, and 'super()' is used to call the parent class constructor."
            },
            {
              "type": "code",
              "language": "java",
              "content": "// Base class\npublic class Animal {\n    protected String name;\n    \n    public Animal(String name) {\n        this.name = name;\n    }\n    \n    public void makeSound() {\n        System.out.println(name + \" makes a sound.\");\n    }\n}\n\n// Derived class\npublic class Dog extends Animal {\n    public Dog(String name) {\n        super(name);\n    }\n    \n    @Override\n    public void makeSound() {\n        System.out.println(name + \" barks: Woof!\");\n    }\n}\n\npublic class InheritanceDemo {\n    public static void main(String[] args) {\n        Animal animal = new Animal(\"Generic Animal\");\n        Dog dog = new Dog(\"Buddy\");\n        \n        animal.makeSound();\n        dog.makeSound(); // Overridden method\n    }\n}"
            },
            {
              "type": "text",
              "content": "Inheritance allows code reuse and establishes an 'is-a' relationship. The 'extends' keyword is used to inherit from a parent class, and 'super()' is used to call the parent constructor."
            }
          ]
        }
      },
      {
        "id": "java-2-2",
        "title": "Polymorphism",
        "duration": "45 minutes",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Polymorphism allows objects of different classes to be treated as objects of a common superclass. It enables flexibility and extensibility in object-oriented design."
            },
            {
              "type": "text",
              "content": "Polymorphism, derived from Greek words meaning 'many forms,' is a core concept in object-oriented programming that allows objects to take on multiple forms. It enables you to write code that can work with objects of different types through a common interface."
            },
            {
              "type": "text",
              "content": "Types of polymorphism in Java:",
              "subsections": [
                "Runtime Polymorphism (Method Overriding): When a subclass provides a specific implementation of a method that is already defined in its parent class",
                "Compile-time Polymorphism (Method Overloading): When multiple methods have the same name but different parameters",
                "Interface Polymorphism: When objects implement interfaces and can be treated as the interface type"
              ]
            },
            {
              "type": "text",
              "content": "Polymorphism provides several advantages including code flexibility, extensibility, and the ability to write more generic code. It's essential for creating maintainable and scalable applications."
            },
            {
              "type": "code",
              "language": "java",
              "content": "// Abstract base class\npublic abstract class Shape {\n    public abstract double calculateArea();\n}\n\n// Concrete implementations\npublic class Circle extends Shape {\n    private double radius;\n    \n    public Circle(double radius) {\n        this.radius = radius;\n    }\n    \n    @Override\n    public double calculateArea() {\n        return Math.PI * radius * radius;\n    }\n}\n\npublic class Rectangle extends Shape {\n    private double width, height;\n    \n    public Rectangle(double width, double height) {\n        this.width = width;\n        this.height = height;\n    }\n    \n    @Override\n    public double calculateArea() {\n        return width * height;\n    }\n}\n\npublic class PolymorphismDemo {\n    public static void main(String[] args) {\n        Shape circle = new Circle(5.0);\n        Shape rectangle = new Rectangle(4.0, 6.0);\n        \n        System.out.println(\"Circle area: \" + circle.calculateArea());\n        System.out.println(\"Rectangle area: \" + rectangle.calculateArea());\n    }\n}"
            },
            {
              "type": "text",
              "content": "Polymorphism comes in two forms: runtime polymorphism (method overriding) and compile-time polymorphism (method overloading). It allows for flexible and extensible code design."
            }
          ]
        }
      },
      {
        "id": "java-2-3",
        "title": "Abstraction",
        "duration": "45 minutes",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Abstraction is the process of hiding complex implementation details and showing only the necessary features. In Java, this is achieved through abstract classes and interfaces."
            },
            {
              "type": "text",
              "content": "Abstraction is a fundamental principle of object-oriented programming that helps manage complexity by hiding unnecessary details and exposing only what is essential. It allows developers to focus on what an object does rather than how it does it."
            },
            {
              "type": "text",
              "content": "Abstraction in Java is implemented through:",
              "subsections": [
                "Abstract Classes: Classes that cannot be instantiated and may contain abstract methods",
                "Interfaces: Pure abstraction that defines a contract for implementing classes",
                "Abstract Methods: Methods declared without implementation that must be implemented by subclasses",
                "Concrete Methods: Methods with complete implementation that can be inherited"
              ]
            },
            {
              "type": "text",
              "content": "Benefits of abstraction include simplified code, better organization, and the ability to change implementation details without affecting the rest of the system. It promotes loose coupling and high cohesion in software design."
            },
            {
              "type": "code",
              "language": "java",
              "content": "// Abstract class example\npublic abstract class BankAccount {\n    protected double balance;\n    \n    public abstract void deposit(double amount);\n    public abstract void withdraw(double amount);\n}\n\n// Concrete implementation\npublic class SavingsAccount extends BankAccount {\n    @Override\n    public void deposit(double amount) {\n        if (amount > 0) balance += amount;\n    }\n    \n    @Override\n    public void withdraw(double amount) {\n        if (amount <= balance) balance -= amount;\n    }\n}\n\n// Interface example\npublic interface Payable {\n    double calculatePayment();\n}\n\npublic class Employee implements Payable {\n    private double hourlyRate;\n    \n    public Employee(double hourlyRate) {\n        this.hourlyRate = hourlyRate;\n    }\n    \n    @Override\n    public double calculatePayment() {\n        return hourlyRate * 40;\n    }\n}"
            },
            {
              "type": "text",
              "content": "Abstraction helps manage complexity by hiding implementation details. Abstract classes can have both abstract and concrete methods, while interfaces define contracts that implementing classes must fulfill."
            }
          ]
        }
      },
      {
        "id": "java-2-4",
        "title": "Encapsulation",
        "duration": "30 minutes",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Encapsulation is the bundling of data and methods that operate on that data within a single unit (class) and hiding the internal state. It's achieved through access modifiers and getter/setter methods."
            },
            {
              "type": "text",
              "content": "Encapsulation is a fundamental principle of object-oriented programming that combines data and the methods that operate on that data into a single unit, while hiding the internal implementation details from the outside world."
            },
            {
              "type": "text",
              "content": "Key components of encapsulation:",
              "subsections": [
                "Data Hiding: Making fields private to prevent direct access from outside the class",
                "Access Modifiers: Using private, protected, and public to control access levels",
                "Getter Methods: Public methods that provide read access to private fields",
                "Setter Methods: Public methods that provide write access to private fields with validation",
                "Business Logic: Methods that implement the class's behavior and rules"
              ]
            },
            {
              "type": "text",
              "content": "Encapsulation provides several benefits including data security, code maintainability, and the ability to change internal implementation without affecting external code. It's essential for creating robust and secure applications."
            },
            {
              "type": "code",
              "language": "java",
              "content": "public class Student {\n    private String name;\n    private double gpa;\n    \n    public Student(String name) {\n        this.name = name;\n        this.gpa = 0.0;\n    }\n    \n    // Getter\n    public String getName() {\n        return name;\n    }\n    \n    public double getGpa() {\n        return gpa;\n    }\n    \n    // Setter with validation\n    public void setGpa(double gpa) {\n        if (gpa >= 0.0 && gpa <= 4.0) {\n            this.gpa = gpa;\n        }\n    }\n}\n\npublic class EncapsulationDemo {\n    public static void main(String[] args) {\n        Student student = new Student(\"Alice\");\n        student.setGpa(3.8);\n        System.out.println(\"GPA: \" + student.getGpa());\n    }\n}"
            },
            {
              "type": "text",
              "content": "Encapsulation provides data hiding and protection through access modifiers (private, protected, public). Getter and setter methods control access to private fields, allowing validation and business logic."
            }
          ]
        }
      },
      {
        "id": "java-2-5",
        "title": "Interfaces",
        "duration": "45 minutes",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Interfaces in Java define a contract that implementing classes must follow. They provide a way to achieve multiple inheritance and define common behavior across different classes."
            },
            {
              "type": "text",
              "content": "Interfaces are a powerful feature in Java that provide a way to achieve abstraction and define a contract that classes must implement. They serve as a blueprint for classes, specifying what methods must be implemented without providing the implementation details."
            },
            {
              "type": "text",
              "content": "Key characteristics of interfaces:",
              "subsections": [
                "Contract Definition: Interfaces define what methods implementing classes must provide",
                "Multiple Implementation: A class can implement multiple interfaces",
                "Pure Abstraction: Interfaces contain only method signatures (before Java 8)",
                "Default Methods: Java 8+ allows interfaces to have default method implementations",
                "Static Methods: Interfaces can contain static methods (Java 8+)",
                "Constants: Interfaces can contain public static final constants"
              ]
            },
            {
              "type": "text",
              "content": "Interfaces provide several advantages including loose coupling, support for multiple inheritance, and the ability to create pluggable components. They are essential for creating flexible and extensible software architectures."
            },
            {
              "type": "code",
              "language": "java",
              "content": "// Single interface\npublic interface Vehicle {\n    void start();\n    void stop();\n}\n\n// Multiple interface implementation\npublic interface Electric {\n    void charge();\n}\n\npublic class Car implements Vehicle {\n    @Override\n    public void start() {\n        System.out.println(\"Car started.\");\n    }\n    \n    @Override\n    public void stop() {\n        System.out.println(\"Car stopped.\");\n    }\n}\n\npublic class ElectricCar implements Vehicle, Electric {\n    @Override\n    public void start() {\n        System.out.println(\"Electric car started.\");\n    }\n    \n    @Override\n    public void stop() {\n        System.out.println(\"Electric car stopped.\");\n    }\n    \n    @Override\n    public void charge() {\n        System.out.println(\"Charging...\");\n    }\n}"
            },
            {
              "type": "text",
              "content": "Interfaces provide a way to define common behavior across different classes. A class can implement multiple interfaces, achieving a form of multiple inheritance. Interfaces help create loosely coupled, extensible code."
            }
          ]
        }
      }
    ],
    "quiz": {
      "questions": [
        {
          "question": "What is inheritance in Java?",
          "options": [
            "A way to create multiple objects from a class",
            "A mechanism that allows a class to inherit properties and methods from another class",
            "A way to hide data within a class",
            "A method to create abstract classes"
          ],
          "correct": 1,
          "explanation": "Inheritance allows a class to inherit properties and methods from a parent class, promoting code reuse and establishing hierarchical relationships."
        },
        {
          "question": "Which keyword is used to inherit from a parent class?",
          "options": [
            "implements",
            "extends",
            "inherits",
            "super"
          ],
          "correct": 1,
          "explanation": "The 'extends' keyword is used to inherit from a parent class in Java."
        },
        {
          "question": "What is polymorphism?",
          "options": [
            "The ability to create multiple objects",
            "The ability of different objects to respond to the same method call in different ways",
            "The process of hiding implementation details",
            "The bundling of data and methods"
          ],
          "correct": 1,
          "explanation": "Polymorphism allows objects of different classes to be treated as objects of a common superclass and respond to method calls differently."
        },
        {
          "question": "What is the purpose of the 'abstract' keyword?",
          "options": [
            "To create a final class",
            "To create a class that cannot be instantiated and may contain abstract methods",
            "To create a private class",
            "To create a static class"
          ],
          "correct": 1,
          "explanation": "The 'abstract' keyword creates a class that cannot be instantiated and may contain abstract methods that must be implemented by subclasses."
        },
        {
          "question": "What is encapsulation?",
          "options": [
            "The process of creating multiple classes",
            "The bundling of data and methods that operate on that data within a single unit",
            "The process of inheriting from multiple classes",
            "The creation of abstract methods"
          ],
          "correct": 1,
          "explanation": "Encapsulation is the bundling of data and methods that operate on that data within a single unit (class) and hiding the internal state."
        }
      ]
    }
  }
} 