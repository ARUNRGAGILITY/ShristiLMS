{
  "module": {
    "title": "Advanced Java Features",
    "description": "Master advanced Java features including generics, annotations, reflection, and modern Java features",
    "duration": "120 minutes",
    "lessons": [
      {
        "id": "java-6-1",
        "title": "Generics",
        "duration": "60 minutes",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Generics provide type safety and eliminate the need for casting. They allow you to write code that works with different types while maintaining compile-time type checking."
            },
            {
              "type": "text",
              "content": "Generics are a powerful feature introduced in Java 5 that enable type-safe programming by allowing classes, interfaces, and methods to operate on objects of various types while providing compile-time type safety. They eliminate the need for casting and reduce the risk of ClassCastException."
            },
            {
              "type": "text",
              "content": "Key concepts of generics:",
              "subsections": [
                "Type Parameters: Placeholders for types (T, E, K, V are common conventions)",
                "Type Safety: Compile-time checking prevents type-related runtime errors",
                "Type Erasure: Generic type information is removed at runtime for backward compatibility",
                "Bounded Types: Restricting type parameters to specific hierarchies",
                "Wildcards: Using ? for unknown types with upper and lower bounds"
              ]
            },
            {
              "type": "text",
              "content": "Benefits of generics:",
              "subsections": [
                "Type Safety: Prevents ClassCastException at runtime",
                "Code Reuse: Write once, use with multiple types",
                "Performance: Eliminates need for casting and boxing/unboxing",
                "Readability: Code is more self-documenting",
                "Maintainability: Easier to refactor and modify"
              ]
            },
            {
              "type": "text",
              "content": "Generics are extensively used in the Java Collections Framework and are essential for creating reusable, type-safe code. Understanding generics is crucial for modern Java development."
            },
            {
              "type": "code",
              "language": "java",
              "content": "import java.util.*;\n\npublic class GenericsDemo {\n    public static void main(String[] args) {\n        // Generic class\n        Box<String> stringBox = new Box<>(\"Hello, Generics!\");\n        Box<Integer> intBox = new Box<>(42);\n        \n        System.out.println(\"String box: \" + stringBox.getContent());\n        System.out.println(\"Integer box: \" + intBox.getContent());\n        \n        // Generic method\n        String[] strings = {\"Apple\", \"Banana\"};\n        Integer[] numbers = {1, 2, 3};\n        \n        System.out.println(\"First string: \" + getFirst(strings));\n        System.out.println(\"First number: \" + getFirst(numbers));\n        \n        // Generic collections\n        List<String> stringList = new ArrayList<>();\n        stringList.add(\"Java\");\n        stringList.add(\"Python\");\n        \n        System.out.println(\"String list: \" + stringList);\n        \n        // Wildcards\n        printList(stringList);\n        printList(Arrays.asList(1, 2, 3));\n    }\n    \n    // Generic method\n    public static <T> T getFirst(T[] array) {\n        return array.length > 0 ? array[0] : null;\n    }\n    \n    // Generic method with wildcard\n    public static void printList(List<?> list) {\n        for (Object item : list) {\n            System.out.print(item + \" \");\n        }\n        System.out.println();\n    }\n}\n\n// Generic class\nclass Box<T> {\n    private T content;\n    \n    public Box(T content) {\n        this.content = content;\n    }\n    \n    public T getContent() {\n        return content;\n    }\n}"
            },
            {
              "type": "text",
              "content": "Generics provide type safety at compile time. Type parameters are specified in angle brackets. Wildcards (?) allow flexibility with unknown types. Bounded generics restrict types to specific hierarchies."
            }
          ]
        }
      },
      {
        "id": "java-6-2",
        "title": "Annotations",
        "duration": "45 minutes",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Annotations provide metadata about code elements. They can be processed at compile time or runtime and are used for documentation, validation, and code generation."
            },
            {
              "type": "text",
              "content": "Annotations are a form of metadata that can be added to Java code elements such as classes, methods, fields, parameters, and packages. They provide information about the code that can be used by the compiler, runtime environment, or other tools to generate code, perform validation, or provide additional functionality."
            },
            {
              "type": "text",
              "content": "Key characteristics of annotations:",
              "subsections": [
                "Metadata: Annotations provide information about code without affecting its execution",
                "Retention: Annotations can be available at compile time, runtime, or both",
                "Target: Annotations can be applied to specific code elements",
                "Processing: Annotations can be processed by annotation processors or reflection",
                "Built-in: Java provides several built-in annotations for common use cases"
              ]
            },
            {
              "type": "text",
              "content": "Built-in annotations in Java:",
              "subsections": [
                "@Override: Indicates that a method overrides a superclass method",
                "@Deprecated: Marks code as deprecated and warns against its use",
                "@SuppressWarnings: Suppresses compiler warnings for specific code",
                "@FunctionalInterface: Indicates that an interface is a functional interface",
                "@SafeVarargs: Suppresses warnings for varargs methods",
                "@Generated: Marks code as generated by a tool"
              ]
            },
            {
              "type": "text",
              "content": "Annotation retention policies:",
              "subsections": [
                "SOURCE: Annotations are discarded by the compiler",
                "CLASS: Annotations are recorded in the class file but not available at runtime",
                "RUNTIME: Annotations are recorded in the class file and available at runtime"
              ]
            },
            {
              "type": "text",
              "content": "Common use cases for annotations include validation, dependency injection, testing frameworks, serialization, and code generation. They enable declarative programming and reduce boilerplate code."
            },
            {
              "type": "code",
              "language": "java",
              "content": "import java.lang.annotation.*;\nimport java.lang.reflect.*;\n\npublic class AnnotationsDemo {\n    public static void main(String[] args) {\n        // Built-in annotations\n        Child child = new Child();\n        child.display();\n        \n        @SuppressWarnings(\"unchecked\")\n        List<String> list = new ArrayList();\n        \n        // Custom annotations\n        @Author(name = \"John Doe\", date = \"2024-01-15\")\n        class AnnotatedClass {\n            @NotNull\n            private String name;\n            \n            @Min(value = 0)\n            @Max(value = 100)\n            private int age;\n            \n            public AnnotatedClass(String name, int age) {\n                this.name = name;\n                this.age = age;\n            }\n        }\n        \n        AnnotatedClass obj = new AnnotatedClass(\"Alice\", 25);\n        \n        // Process annotations\n        processAnnotations(AnnotatedClass.class);\n        validateObject(obj);\n    }\n    \n    public static void processAnnotations(Class<?> clazz) {\n        Annotation[] classAnnotations = clazz.getAnnotations();\n        System.out.println(\"Class annotations:\");\n        for (Annotation annotation : classAnnotations) {\n            System.out.println(\"  \" + annotation.annotationType().getSimpleName());\n        }\n    }\n    \n    public static void validateObject(Object obj) {\n        Class<?> clazz = obj.getClass();\n        Field[] fields = clazz.getDeclaredFields();\n        \n        for (Field field : fields) {\n            field.setAccessible(true);\n            \n            if (field.isAnnotationPresent(NotNull.class)) {\n                try {\n                    Object value = field.get(obj);\n                    if (value == null) {\n                        System.out.println(\"Validation failed: \" + field.getName() + \" cannot be null\");\n                    } else {\n                        System.out.println(\"Validation passed: \" + field.getName() + \" is not null\");\n                    }\n                } catch (IllegalAccessException e) {\n                    System.out.println(\"Error accessing field: \" + e.getMessage());\n                }\n            }\n        }\n    }\n}\n\n// Custom annotations\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\n@interface Author {\n    String name();\n    String date();\n}\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\n@interface NotNull {\n}\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\n@interface Min {\n    int value();\n}\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\n@interface Max {\n    int value();\n}\n\nclass Parent {\n    public void display() {\n        System.out.println(\"Parent class\");\n    }\n}\n\nclass Child extends Parent {\n    @Override\n    public void display() {\n        System.out.println(\"Child class (overridden method)\");\n    }\n}"
            },
            {
              "type": "text",
              "content": "Annotations provide metadata about code elements. @Retention specifies when annotations are available. @Target specifies where annotations can be applied. Custom annotations can be processed at runtime using reflection."
            }
          ]
        }
      },
      {
        "id": "java-6-3",
        "title": "Reflection",
        "duration": "45 minutes",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Reflection allows you to examine and modify the behavior of classes, methods, and fields at runtime. It's powerful but should be used carefully due to performance implications."
            },
            {
              "type": "text",
              "content": "Reflection is a powerful feature in Java that allows a program to examine and modify its own structure and behavior at runtime. It provides the ability to inspect classes, interfaces, fields, and methods, as well as to instantiate objects, invoke methods, and access fields dynamically."
            },
            {
              "type": "text",
              "content": "Key capabilities of reflection:",
              "subsections": [
                "Class Inspection: Examine class structure, methods, fields, and constructors",
                "Dynamic Instantiation: Create objects without knowing their class at compile time",
                "Method Invocation: Call methods dynamically using their names",
                "Field Access: Read and modify field values, including private fields",
                "Annotation Processing: Access and process annotations at runtime"
              ]
            },
            {
              "type": "text",
              "content": "Common use cases for reflection:",
              "subsections": [
                "Frameworks: Dependency injection, serialization, and ORM frameworks",
                "Testing: Unit testing frameworks use reflection to access private members",
                "Plugins: Dynamic loading and instantiation of plugin classes",
                "Configuration: Reading configuration from annotations or external sources",
                "Debugging: Tools that need to inspect program structure"
              ]
            },
            {
              "type": "text",
              "content": "Performance considerations:",
              "subsections": [
                "Overhead: Reflection operations are slower than direct method calls",
                "Security: Accessing private members can break encapsulation",
                "Caching: Reflection results should be cached when possible",
                "Compile-time Safety: Reflection bypasses compile-time type checking",
                "Maintenance: Code using reflection can be harder to understand and maintain"
              ]
            },
            {
              "type": "text",
              "content": "Reflection should be used judiciously, primarily in frameworks and tools where the benefits outweigh the performance and maintenance costs. It's essential for many modern Java frameworks and libraries."
            },
            {
              "type": "code",
              "language": "java",
              "content": "import java.lang.reflect.*;\n\npublic class ReflectionDemo {\n    public static void main(String[] args) {\n        // Get class information\n        Class<?> stringClass = String.class;\n        System.out.println(\"Class name: \" + stringClass.getName());\n        System.out.println(\"Simple name: \" + stringClass.getSimpleName());\n        \n        // Get methods\n        Method[] methods = stringClass.getMethods();\n        System.out.println(\"Number of methods: \" + methods.length);\n        \n        // Creating objects using reflection\n        try {\n            Constructor<String> stringConstructor = String.class.getConstructor(String.class);\n            String reflectedString = stringConstructor.newInstance(\"Hello Reflection!\");\n            System.out.println(\"Created string: \" + reflectedString);\n        } catch (Exception e) {\n            System.out.println(\"Error creating objects: \" + e.getMessage());\n        }\n        \n        // Invoking methods using reflection\n        try {\n            String testString = \"Hello World\";\n            Method lengthMethod = String.class.getMethod(\"length\");\n            int length = (Integer) lengthMethod.invoke(testString);\n            System.out.println(\"String length: \" + length);\n        } catch (Exception e) {\n            System.out.println(\"Error invoking methods: \" + e.getMessage());\n        }\n        \n        // Accessing private fields\n        try {\n            TestObject testObj = new TestObject(\"Private Field\", 42);\n            Class<?> testClass = testObj.getClass();\n            \n            Field privateField = testClass.getDeclaredField(\"privateField\");\n            privateField.setAccessible(true);\n            \n            String fieldValue = (String) privateField.get(testObj);\n            System.out.println(\"Private field value: \" + fieldValue);\n            \n            privateField.set(testObj, \"Modified Private Field\");\n            System.out.println(\"After modification: \" + testObj);\n        } catch (Exception e) {\n            System.out.println(\"Error accessing fields: \" + e.getMessage());\n        }\n    }\n}\n\nclass TestObject {\n    private String privateField;\n    public int publicField;\n    \n    public TestObject(String privateField, int publicField) {\n        this.privateField = privateField;\n        this.publicField = publicField;\n    }\n    \n    @Override\n    public String toString() {\n        return \"TestObject{privateField='\" + privateField + \"', publicField=\" + publicField + '}';\n    }\n}"
            },
            {
              "type": "text",
              "content": "Reflection allows runtime examination of classes, methods, and fields. It can create objects, invoke methods, and access private members. Use reflection carefully as it can impact performance and break encapsulation."
            }
          ]
        }
      },
      {
        "id": "java-6-4",
        "title": "Modern Java Features",
        "duration": "60 minutes",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Modern Java (Java 8+) introduces features like lambda expressions, streams, optionals, and modules that make code more concise and functional."
            },
            {
              "type": "text",
              "content": "Modern Java features, introduced starting with Java 8, have transformed the language to support functional programming paradigms while maintaining backward compatibility. These features make Java code more expressive, readable, and maintainable."
            },
            {
              "type": "text",
              "content": "Lambda expressions and functional programming:",
              "subsections": [
                "Lambda Expressions: Anonymous functions that can be passed as arguments",
                "Functional Interfaces: Interfaces with a single abstract method",
                "Method References: Shorthand syntax for lambda expressions",
                "Built-in Functional Interfaces: Predicate, Function, Consumer, Supplier",
                "Stream API: Declarative data processing with functional operations"
              ]
            },
            {
              "type": "text",
              "content": "Streams API features:",
              "subsections": [
                "Intermediate Operations: filter, map, flatMap, sorted, distinct",
                "Terminal Operations: collect, reduce, forEach, findFirst, anyMatch",
                "Parallel Streams: Automatic parallelization for performance",
                "Collectors: Predefined collectors for common operations",
                "Lazy Evaluation: Operations are only executed when needed"
              ]
            },
            {
              "type": "text",
              "content": "Optional class and null safety:",
              "subsections": [
                "Null Safety: Explicit handling of potentially null values",
                "Method Chaining: map, flatMap, filter operations on Optional",
                "Default Values: orElse, orElseGet, orElseThrow methods",
                "Conditional Execution: ifPresent, ifPresentOrElse methods",
                "Best Practices: Use Optional for return types, not parameters"
              ]
            },
            {
              "type": "text",
              "content": "Date and Time API improvements:",
              "subsections": [
                "Immutable Classes: LocalDate, LocalTime, LocalDateTime are immutable",
                "Time Zones: ZonedDateTime and ZoneId for timezone handling",
                "Periods and Durations: Period for date-based time, Duration for time-based",
                "Formatting: DateTimeFormatter for flexible date/time formatting",
                "Legacy Support: Methods to convert between old and new APIs"
              ]
            },
            {
              "type": "text",
              "content": "Other modern features:",
              "subsections": [
                "Default Methods: Interfaces can have method implementations",
                "Static Methods in Interfaces: Utility methods in interfaces",
                "Try-with-resources: Automatic resource management",
                "Type Inference: var keyword for local variable type inference (Java 10+)",
                "Text Blocks: Multi-line string literals (Java 13+)"
              ]
            },
            {
              "type": "text",
              "content": "These modern features have made Java more competitive with other languages while maintaining its enterprise strengths. They enable more functional, declarative programming styles that are often more readable and less error-prone."
            },
            {
              "type": "code",
              "language": "java",
              "content": "import java.util.*;\nimport java.util.stream.*;\nimport java.time.*;\n\npublic class ModernJavaFeatures {\n    public static void main(String[] args) {\n        // Lambda expressions\n        List<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\n        names.forEach(name -> System.out.println(\"Hello, \" + name));\n        \n        // Streams API\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> evenSquares = numbers.stream()\n                                          .filter(n -> n % 2 == 0)\n                                          .map(n -> n * n)\n                                          .collect(Collectors.toList());\n        System.out.println(\"Even squares: \" + evenSquares);\n        \n        // Optional class\n        Optional<String> optionalName = Optional.of(\"John\");\n        optionalName.ifPresent(name -> System.out.println(\"Name is: \" + name));\n        \n        String result = optionalName.orElse(\"Unknown\");\n        System.out.println(\"Result: \" + result);\n        \n        // Method references\n        List<String> upperNames = names.stream()\n                                       .map(String::toUpperCase)\n                                       .collect(Collectors.toList());\n        System.out.println(\"Upper names: \" + upperNames);\n        \n        // Date/Time API\n        LocalDate today = LocalDate.now();\n        LocalTime now = LocalTime.now();\n        \n        System.out.println(\"Today: \" + today);\n        System.out.println(\"Now: \" + now);\n        \n        // Date arithmetic\n        LocalDate tomorrow = today.plusDays(1);\n        System.out.println(\"Tomorrow: \" + tomorrow);\n        \n        // Default methods in interfaces\n        Vehicle car = new Car();\n        car.start();\n        car.honk(); // Default method\n        car.stop();\n    }\n}\n\ninterface Vehicle {\n    void start();\n    void stop();\n    \n    default void honk() {\n        System.out.println(\"Honk! Honk!\");\n    }\n}\n\nclass Car implements Vehicle {\n    @Override\n    public void start() {\n        System.out.println(\"Car starting...\");\n    }\n    \n    @Override\n    public void stop() {\n        System.out.println(\"Car stopping...\");\n    }\n}"
            },
            {
              "type": "text",
              "content": "Lambda expressions provide concise functional programming. Streams API enables declarative data processing. Optional helps handle null values safely. Modern Date/Time API is more robust than legacy classes."
            }
          ]
        }
      }
    ],
    "quiz": {
      "questions": [
        {
          "question": "What is the main benefit of using generics?",
          "options": [
            "They make code run faster",
            "They provide compile-time type safety",
            "They reduce memory usage",
            "They make code more readable"
          ],
          "correct": 1,
          "explanation": "Generics provide compile-time type safety, eliminating the need for casting and preventing ClassCastException at runtime."
        },
        {
          "question": "What does the @Override annotation do?",
          "options": [
            "It makes a method run faster",
            "It indicates that a method overrides a superclass method",
            "It prevents a method from being overridden",
            "It makes a method static"
          ],
          "correct": 1,
          "explanation": "The @Override annotation indicates that a method is intended to override a method in a superclass, helping catch errors at compile time."
        },
        {
          "question": "What is reflection used for?",
          "options": [
            "To make code run faster",
            "To examine and modify class behavior at runtime",
            "To create new programming languages",
            "To optimize memory usage"
          ],
          "correct": 1,
          "explanation": "Reflection allows examining and modifying the behavior of classes, methods, and fields at runtime, though it should be used carefully due to performance implications."
        },
        {
          "question": "What is a lambda expression?",
          "options": [
            "A way to create anonymous functions",
            "A type of variable",
            "A method name",
            "A class name"
          ],
          "correct": 0,
          "explanation": "Lambda expressions provide a way to create anonymous functions, making code more concise and enabling functional programming in Java."
        },
        {
          "question": "What is the purpose of the Optional class?",
          "options": [
            "To make code run faster",
            "To handle null values safely",
            "To create new objects",
            "To sort collections"
          ],
          "correct": 1,
          "explanation": "The Optional class provides a way to handle null values safely, encouraging explicit null checking and reducing NullPointerException."
        }
      ]
    }
  }
} 