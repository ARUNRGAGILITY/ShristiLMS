{
  "module": {
    "title": "Advanced Java Features",
    "description": "Master advanced Java features including generics, annotations, reflection, and modern Java features",
    "lessons": [
      {
        "id": "java-6-1",
        "title": "Generics",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Generics provide type safety and eliminate the need for casting. They allow you to write code that works with different types while maintaining compile-time type checking."
            },
            {
              "type": "text",
              "content": "Generics are a powerful feature introduced in Java 5 that enable type-safe programming by allowing classes, interfaces, and methods to operate on objects of various types while providing compile-time type safety. They eliminate the need for casting and reduce the risk of ClassCastException."
            },
            {
              "type": "text",
              "content": "Key concepts of generics:",
              "subsections": [
                "Type Parameters: Placeholders for types (T, E, K, V are common conventions)",
                "Type Safety: Compile-time checking prevents type-related runtime errors",
                "Type Erasure: Generic type information is removed at runtime for backward compatibility",
                "Bounded Types: Restricting type parameters to specific hierarchies",
                "Wildcards: Using ? for unknown types with upper and lower bounds"
              ]
            },
            {
              "type": "text",
              "content": "Benefits of generics:",
              "subsections": [
                "Type Safety: Prevents ClassCastException at runtime",
                "Code Reuse: Write once, use with multiple types",
                "Performance: Eliminates need for casting and boxing/unboxing",
                "Readability: Code is more self-documenting",
                "Maintainability: Easier to refactor and modify"
              ]
            },
            {
              "type": "text",
              "content": "Generics are extensively used in the Java Collections Framework and are essential for creating reusable, type-safe code. Understanding generics is crucial for modern Java development."
            },
            {
              "type": "code",
              "language": "java",
              "content": "import java.util.*;\n\npublic class GenericsDemo {\n    public static void main(String[] args) {\n        // Generic class demonstration\n        System.out.println(\"=== Generic Box ===\");\n        Box<String> stringBox = new Box<>(\"Hello, Generics!\");\n        Box<Integer> intBox = new Box<>(42);\n        Box<Double> doubleBox = new Box<>(3.14);\n        \n        System.out.println(\"String box: \" + stringBox.getContent());\n        System.out.println(\"Integer box: \" + intBox.getContent());\n        System.out.println(\"Double box: \" + doubleBox.getContent());\n        \n        // Generic method demonstration\n        System.out.println(\"\\n=== Generic Methods ===\");\n        String[] strings = {\"Apple\", \"Banana\", \"Orange\"};\n        Integer[] numbers = {1, 2, 3, 4, 5};\n        \n        System.out.println(\"First string: \" + getFirst(strings));\n        System.out.println(\"First number: \" + getFirst(numbers));\n        \n        // Generic method with multiple type parameters\n        Pair<String, Integer> pair1 = new Pair<>(\"Age\", 25);\n        Pair<Double, String> pair2 = new Pair<>(3.14, \"Pi\");\n        \n        System.out.println(\"Pair 1: \" + pair1.getFirst() + \" = \" + pair1.getSecond());\n        System.out.println(\"Pair 2: \" + pair2.getFirst() + \" = \" + pair2.getSecond());\n        \n        // Generic collections\n        System.out.println(\"\\n=== Generic Collections ===\");\n        List<String> stringList = new ArrayList<>();\n        stringList.add(\"Java\");\n        stringList.add(\"Python\");\n        stringList.add(\"C++\");\n        \n        List<Integer> numberList = new ArrayList<>();\n        numberList.add(10);\n        numberList.add(20);\n        numberList.add(30);\n        \n        System.out.println(\"String list: \" + stringList);\n        System.out.println(\"Number list: \" + numberList);\n        \n        // Generic method with wildcards\n        System.out.println(\"\\n=== Wildcards ===\");\n        List<Number> numberList2 = new ArrayList<>();\n        numberList2.add(1);\n        numberList2.add(2.5);\n        numberList2.add(3L);\n        \n        printList(stringList);\n        printList(numberList);\n        printList(numberList2);\n        \n        // Bounded generics\n        System.out.println(\"\\n=== Bounded Generics ===\");\n        NumberBox<Integer> intNumberBox = new NumberBox<>(100);\n        NumberBox<Double> doubleNumberBox = new NumberBox<>(99.5);\n        \n        System.out.println(\"Integer box value: \" + intNumberBox.getValue());\n        System.out.println(\"Double box value: \" + doubleNumberBox.getValue());\n        \n        // Generic stack implementation\n        System.out.println(\"\\n=== Generic Stack ===\");\n        Stack<String> stringStack = new Stack<>();\n        stringStack.push(\"First\");\n        stringStack.push(\"Second\");\n        stringStack.push(\"Third\");\n        \n        while (!stringStack.isEmpty()) {\n            System.out.println(\"Popped: \" + stringStack.pop());\n        }\n        \n        // Generic comparator\n        System.out.println(\"\\n=== Generic Comparator ===\");\n        List<Person> people = Arrays.asList(\n            new Person(\"Alice\", 25),\n            new Person(\"Bob\", 30),\n            new Person(\"Charlie\", 20)\n        );\n        \n        Collections.sort(people, new PersonComparator<>());\n        System.out.println(\"Sorted people: \" + people);\n    }\n    \n    // Generic method\n    public static <T> T getFirst(T[] array) {\n        if (array.length > 0) {\n            return array[0];\n        }\n        return null;\n    }\n    \n    // Generic method with wildcard\n    public static void printList(List<?> list) {\n        for (Object item : list) {\n            System.out.print(item + \" \");\n        }\n        System.out.println();\n    }\n}\n\n// Generic class\nclass Box<T> {\n    private T content;\n    \n    public Box(T content) {\n        this.content = content;\n    }\n    \n    public T getContent() {\n        return content;\n    }\n    \n    public void setContent(T content) {\n        this.content = content;\n    }\n}\n\n// Generic class with multiple type parameters\nclass Pair<T, U> {\n    private T first;\n    private U second;\n    \n    public Pair(T first, U second) {\n        this.first = first;\n        this.second = second;\n    }\n    \n    public T getFirst() {\n        return first;\n    }\n    \n    public U getSecond() {\n        return second;\n    }\n}\n\n// Bounded generic class\nclass NumberBox<T extends Number> {\n    private T value;\n    \n    public NumberBox(T value) {\n        this.value = value;\n    }\n    \n    public T getValue() {\n        return value;\n    }\n    \n    public double getDoubleValue() {\n        return value.doubleValue();\n    }\n}\n\n// Generic stack implementation\nclass Stack<T> {\n    private List<T> elements = new ArrayList<>();\n    \n    public void push(T element) {\n        elements.add(element);\n    }\n    \n    public T pop() {\n        if (isEmpty()) {\n            throw new IllegalStateException(\"Stack is empty\");\n        }\n        return elements.remove(elements.size() - 1);\n    }\n    \n    public T peek() {\n        if (isEmpty()) {\n            throw new IllegalStateException(\"Stack is empty\");\n        }\n        return elements.get(elements.size() - 1);\n    }\n    \n    public boolean isEmpty() {\n        return elements.isEmpty();\n    }\n}\n\n// Person class for demonstration\nclass Person {\n    private String name;\n    private int age;\n    \n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    public String getName() { return name; }\n    public int getAge() { return age; }\n    \n    @Override\n    public String toString() {\n        return name + \"(\" + age + \")\";\n    }\n}\n\n// Generic comparator\nclass PersonComparator<T extends Person> implements Comparator<T> {\n    @Override\n    public int compare(T p1, T p2) {\n        return Integer.compare(p1.getAge(), p2.getAge());\n    }\n}"
            },
            {
              "type": "text",
              "content": "Generics provide type safety at compile time. Type parameters are specified in angle brackets. Wildcards (?) allow flexibility with unknown types. Bounded generics restrict types to specific hierarchies."
            }
          ]
        }
      },
      {
        "id": "java-6-2",
        "title": "Annotations",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Annotations provide metadata about code elements. They can be processed at compile time or runtime and are used for documentation, validation, and code generation."
            },
            {
              "type": "code",
              "language": "java",
              "content": "import java.lang.annotation.*;\nimport java.lang.reflect.*;\nimport java.util.*;\n\npublic class AnnotationsDemo {\n    public static void main(String[] args) {\n        // Built-in annotations demonstration\n        System.out.println(\"=== Built-in Annotations ===\");\n        \n        // @Override annotation\n        Child child = new Child();\n        child.display();\n        \n        // @Deprecated annotation\n        DeprecatedClass deprecated = new DeprecatedClass();\n        deprecated.oldMethod(); // This will show a warning\n        \n        // @SuppressWarnings annotation\n        @SuppressWarnings(\"unchecked\")\n        List<String> list = new ArrayList();\n        list.add(\"Suppressed warning\");\n        \n        // Custom annotations demonstration\n        System.out.println(\"\\n=== Custom Annotations ===\");\n        \n        // Using custom annotations\n        @Author(name = \"John Doe\", date = \"2024-01-15\")\n        @Version(major = 1, minor = 0)\n        class AnnotatedClass {\n            @NotNull\n            private String name;\n            \n            @Min(value = 0)\n            @Max(value = 100)\n            private int age;\n            \n            public AnnotatedClass(String name, int age) {\n                this.name = name;\n                this.age = age;\n            }\n            \n            @Override\n            public String toString() {\n                return \"AnnotatedClass{name='\" + name + \"', age=\" + age + '}';\n            }\n        }\n        \n        AnnotatedClass obj = new AnnotatedClass(\"Alice\", 25);\n        System.out.println(obj);\n        \n        // Reflection to process annotations\n        System.out.println(\"\\n=== Processing Annotations ===\");\n        processAnnotations(AnnotatedClass.class);\n        \n        // Runtime annotation processing\n        System.out.println(\"\\n=== Runtime Validation ===\");\n        validateObject(obj);\n        \n        // Method annotations\n        System.out.println(\"\\n=== Method Annotations ===\");\n        TestClass testObj = new TestClass();\n        processMethodAnnotations(testObj);\n    }\n    \n    // Method to process class annotations\n    public static void processAnnotations(Class<?> clazz) {\n        // Get class annotations\n        Annotation[] classAnnotations = clazz.getAnnotations();\n        System.out.println(\"Class annotations:\");\n        for (Annotation annotation : classAnnotations) {\n            System.out.println(\"  \" + annotation.annotationType().getSimpleName());\n        }\n        \n        // Get field annotations\n        Field[] fields = clazz.getDeclaredFields();\n        System.out.println(\"\\nField annotations:\");\n        for (Field field : fields) {\n            Annotation[] fieldAnnotations = field.getAnnotations();\n            if (fieldAnnotations.length > 0) {\n                System.out.println(\"  \" + field.getName() + \":\");\n                for (Annotation annotation : fieldAnnotations) {\n                    System.out.println(\"    \" + annotation.annotationType().getSimpleName());\n                }\n            }\n        }\n    }\n    \n    // Method to validate object using annotations\n    public static void validateObject(Object obj) {\n        Class<?> clazz = obj.getClass();\n        Field[] fields = clazz.getDeclaredFields();\n        \n        for (Field field : fields) {\n            field.setAccessible(true);\n            \n            // Check @NotNull annotation\n            if (field.isAnnotationPresent(NotNull.class)) {\n                try {\n                    Object value = field.get(obj);\n                    if (value == null) {\n                        System.out.println(\"Validation failed: \" + field.getName() + \" cannot be null\");\n                    } else {\n                        System.out.println(\"Validation passed: \" + field.getName() + \" is not null\");\n                    }\n                } catch (IllegalAccessException e) {\n                    System.out.println(\"Error accessing field: \" + e.getMessage());\n                }\n            }\n            \n            // Check @Min and @Max annotations\n            if (field.isAnnotationPresent(Min.class) && field.isAnnotationPresent(Max.class)) {\n                try {\n                    Object value = field.get(obj);\n                    if (value instanceof Number) {\n                        int intValue = ((Number) value).intValue();\n                        Min minAnnotation = field.getAnnotation(Min.class);\n                        Max maxAnnotation = field.getAnnotation(Max.class);\n                        \n                        if (intValue < minAnnotation.value() || intValue > maxAnnotation.value()) {\n                            System.out.println(\"Validation failed: \" + field.getName() + \" value \" + intValue + \" is out of range [\" + minAnnotation.value() + \", \" + maxAnnotation.value() + \"]\");\n                        } else {\n                            System.out.println(\"Validation passed: \" + field.getName() + \" value \" + intValue + \" is in range\");\n                        }\n                    }\n                } catch (IllegalAccessException e) {\n                    System.out.println(\"Error accessing field: \" + e.getMessage());\n                }\n            }\n        }\n    }\n    \n    // Method to process method annotations\n    public static void processMethodAnnotations(Object obj) {\n        Class<?> clazz = obj.getClass();\n        Method[] methods = clazz.getMethods();\n        \n        for (Method method : methods) {\n            if (method.isAnnotationPresent(Test.class)) {\n                Test testAnnotation = method.getAnnotation(Test.class);\n                System.out.println(\"Found test method: \" + method.getName() + \" (enabled: \" + testAnnotation.enabled() + \")\");\n                \n                if (testAnnotation.enabled()) {\n                    try {\n                        method.invoke(obj);\n                        System.out.println(\"  Test executed successfully\");\n                    } catch (Exception e) {\n                        System.out.println(\"  Test failed: \" + e.getMessage());\n                    }\n                }\n            }\n        }\n    }\n}\n\n// Custom annotations\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\n@interface Author {\n    String name();\n    String date();\n}\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\n@interface Version {\n    int major();\n    int minor();\n}\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\n@interface NotNull {\n}\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\n@interface Min {\n    int value();\n}\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\n@interface Max {\n    int value();\n}\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@interface Test {\n    boolean enabled() default true;\n}\n\n// Classes demonstrating built-in annotations\nclass Parent {\n    public void display() {\n        System.out.println(\"Parent class\");\n    }\n}\n\nclass Child extends Parent {\n    @Override\n    public void display() {\n        System.out.println(\"Child class (overridden method)\");\n    }\n}\n\n@Deprecated\nclass DeprecatedClass {\n    @Deprecated\n    public void oldMethod() {\n        System.out.println(\"This method is deprecated\");\n    }\n}\n\n// Test class with method annotations\nclass TestClass {\n    @Test(enabled = true)\n    public void testMethod1() {\n        System.out.println(\"  Running test method 1\");\n    }\n    \n    @Test(enabled = false)\n    public void testMethod2() {\n        System.out.println(\"  This test is disabled\");\n    }\n    \n    @Test\n    public void testMethod3() {\n        System.out.println(\"  Running test method 3\");\n    }\n}"
            },
            {
              "type": "text",
              "content": "Annotations provide metadata about code elements. @Retention specifies when annotations are available. @Target specifies where annotations can be applied. Custom annotations can be processed at runtime using reflection."
            }
          ]
        }
      },
      {
        "id": "java-6-3",
        "title": "Reflection",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Reflection allows you to examine and modify the behavior of classes, methods, and fields at runtime. It's powerful but should be used carefully due to performance implications."
            },
            {
              "type": "code",
              "language": "java",
              "content": "import java.lang.reflect.*;\nimport java.util.*;\n\npublic class ReflectionDemo {\n    public static void main(String[] args) {\n        // Basic reflection demonstration\n        System.out.println(\"=== Basic Reflection ===\");\n        \n        // Get class information\n        Class<?> stringClass = String.class;\n        System.out.println(\"Class name: \" + stringClass.getName());\n        System.out.println(\"Simple name: \" + stringClass.getSimpleName());\n        System.out.println(\"Package: \" + stringClass.getPackage().getName());\n        System.out.println(\"Is interface: \" + stringClass.isInterface());\n        System.out.println(\"Superclass: \" + stringClass.getSuperclass().getName());\n        \n        // Get constructors\n        System.out.println(\"\\n=== Constructors ===\");\n        Constructor<?>[] constructors = stringClass.getConstructors();\n        System.out.println(\"Number of constructors: \" + constructors.length);\n        for (Constructor<?> constructor : constructors) {\n            System.out.println(\"  \" + constructor.toString());\n        }\n        \n        // Get methods\n        System.out.println(\"\\n=== Methods ===\");\n        Method[] methods = stringClass.getMethods();\n        System.out.println(\"Number of methods: \" + methods.length);\n        for (Method method : methods) {\n            if (method.getName().startsWith(\"get\") || method.getName().startsWith(\"set\")) {\n                System.out.println(\"  \" + method.getName() + \" -> \" + method.getReturnType().getSimpleName());\n            }\n        }\n        \n        // Get fields\n        System.out.println(\"\\n=== Fields ===\");\n        Field[] fields = stringClass.getDeclaredFields();\n        System.out.println(\"Number of declared fields: \" + fields.length);\n        for (Field field : fields) {\n            System.out.println(\"  \" + field.getType().getSimpleName() + \" \" + field.getName());\n        }\n        \n        // Creating objects using reflection\n        System.out.println(\"\\n=== Creating Objects ===\");\n        try {\n            // Create String object using reflection\n            Constructor<String> stringConstructor = String.class.getConstructor(String.class);\n            String reflectedString = stringConstructor.newInstance(\"Hello Reflection!\");\n            System.out.println(\"Created string: \" + reflectedString);\n            \n            // Create ArrayList using reflection\n            Constructor<ArrayList> listConstructor = ArrayList.class.getConstructor();\n            ArrayList<String> reflectedList = listConstructor.newInstance();\n            reflectedList.add(\"Item 1\");\n            reflectedList.add(\"Item 2\");\n            System.out.println(\"Created list: \" + reflectedList);\n            \n        } catch (Exception e) {\n            System.out.println(\"Error creating objects: \" + e.getMessage());\n        }\n        \n        // Invoking methods using reflection\n        System.out.println(\"\\n=== Invoking Methods ===\");\n        try {\n            String testString = \"Hello World\";\n            \n            // Get the length method\n            Method lengthMethod = String.class.getMethod(\"length\");\n            int length = (Integer) lengthMethod.invoke(testString);\n            System.out.println(\"String length: \" + length);\n            \n            // Get the substring method\n            Method substringMethod = String.class.getMethod(\"substring\", int.class, int.class);\n            String substring = (String) substringMethod.invoke(testString, 0, 5);\n            System.out.println(\"Substring: \" + substring);\n            \n            // Get the toUpperCase method\n            Method toUpperCaseMethod = String.class.getMethod(\"toUpperCase\");\n            String upperCase = (String) toUpperCaseMethod.invoke(testString);\n            System.out.println(\"Uppercase: \" + upperCase);\n            \n        } catch (Exception e) {\n            System.out.println(\"Error invoking methods: \" + e.getMessage());\n        }\n        \n        // Accessing and modifying fields\n        System.out.println(\"\\n=== Accessing Fields ===\");\n        try {\n            // Create a test object\n            TestObject testObj = new TestObject(\"Private Field\", 42);\n            System.out.println(\"Original object: \" + testObj);\n            \n            // Get the class\n            Class<?> testClass = testObj.getClass();\n            \n            // Access private fields\n            Field privateField = testClass.getDeclaredField(\"privateField\");\n            privateField.setAccessible(true);\n            \n            // Read private field\n            String fieldValue = (String) privateField.get(testObj);\n            System.out.println(\"Private field value: \" + fieldValue);\n            \n            // Modify private field\n            privateField.set(testObj, \"Modified Private Field\");\n            System.out.println(\"After modification: \" + testObj);\n            \n            // Access all fields\n            Field[] allFields = testClass.getDeclaredFields();\n            System.out.println(\"\\nAll fields:\");\n            for (Field field : allFields) {\n                field.setAccessible(true);\n                System.out.println(\"  \" + field.getName() + \" = \" + field.get(testObj));\n            }\n            \n        } catch (Exception e) {\n            System.out.println(\"Error accessing fields: \" + e.getMessage());\n        }\n        \n        // Dynamic method invocation\n        System.out.println(\"\\n=== Dynamic Method Invocation ===\");\n        try {\n            Calculator calculator = new Calculator();\n            \n            // Invoke add method\n            Method addMethod = Calculator.class.getMethod(\"add\", int.class, int.class);\n            int sum = (Integer) addMethod.invoke(calculator, 5, 3);\n            System.out.println(\"5 + 3 = \" + sum);\n            \n            // Invoke multiply method\n            Method multiplyMethod = Calculator.class.getMethod(\"multiply\", double.class, double.class);\n            double product = (Double) multiplyMethod.invoke(calculator, 4.5, 2.0);\n            System.out.println(\"4.5 * 2.0 = \" + product);\n            \n            // Invoke static method\n            Method staticMethod = Calculator.class.getMethod(\"getVersion\");\n            String version = (String) staticMethod.invoke(null);\n            System.out.println(\"Calculator version: \" + version);\n            \n        } catch (Exception e) {\n            System.out.println(\"Error in dynamic method invocation: \" + e.getMessage());\n        }\n        \n        // Annotation processing with reflection\n        System.out.println(\"\\n=== Annotation Processing ===\");\n        processAnnotationsWithReflection(TestObject.class);\n    }\n    \n    // Method to process annotations using reflection\n    public static void processAnnotationsWithReflection(Class<?> clazz) {\n        System.out.println(\"Processing annotations for: \" + clazz.getSimpleName());\n        \n        // Class annotations\n        Annotation[] classAnnotations = clazz.getAnnotations();\n        if (classAnnotations.length > 0) {\n            System.out.println(\"Class annotations:\");\n            for (Annotation annotation : classAnnotations) {\n                System.out.println(\"  \" + annotation.annotationType().getSimpleName());\n            }\n        }\n        \n        // Method annotations\n        Method[] methods = clazz.getMethods();\n        for (Method method : methods) {\n            Annotation[] methodAnnotations = method.getAnnotations();\n            if (methodAnnotations.length > 0) {\n                System.out.println(\"\\nMethod \" + method.getName() + \" annotations:\");\n                for (Annotation annotation : methodAnnotations) {\n                    System.out.println(\"  \" + annotation.annotationType().getSimpleName());\n                }\n            }\n        }\n        \n        // Field annotations\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field field : fields) {\n            Annotation[] fieldAnnotations = field.getAnnotations();\n            if (fieldAnnotations.length > 0) {\n                System.out.println(\"\\nField \" + field.getName() + \" annotations:\");\n                for (Annotation annotation : fieldAnnotations) {\n                    System.out.println(\"  \" + annotation.annotationType().getSimpleName());\n                }\n            }\n        }\n    }\n}\n\n// Test class for reflection demonstration\nclass TestObject {\n    private String privateField;\n    public int publicField;\n    \n    public TestObject(String privateField, int publicField) {\n        this.privateField = privateField;\n        this.publicField = publicField;\n    }\n    \n    @Override\n    public String toString() {\n        return \"TestObject{privateField='\" + privateField + \"', publicField=\" + publicField + '}';\n    }\n}\n\n// Calculator class for method invocation demonstration\nclass Calculator {\n    public int add(int a, int b) {\n        return a + b;\n    }\n    \n    public double multiply(double a, double b) {\n        return a * b;\n    }\n    \n    public static String getVersion() {\n        return \"1.0.0\";\n    }\n}"
            },
            {
              "type": "text",
              "content": "Reflection allows runtime examination of classes, methods, and fields. It can create objects, invoke methods, and access private members. Use reflection carefully as it can impact performance and break encapsulation."
            }
          ]
        }
      },
      {
        "id": "java-6-4",
        "title": "Modern Java Features",
        "content": {
          "sections": [
            {
              "type": "text",
              "content": "Modern Java (Java 8+) introduces features like lambda expressions, streams, optionals, and modules that make code more concise and functional."
            },
            {
              "type": "code",
              "language": "java",
              "content": "import java.util.*;\nimport java.util.stream.*;\nimport java.util.function.*;\nimport java.time.*;\nimport java.time.format.*;\n\npublic class ModernJavaFeatures {\n    public static void main(String[] args) {\n        // Lambda expressions\n        System.out.println(\"=== Lambda Expressions ===\");\n        \n        // Functional interfaces with lambdas\n        List<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eve\");\n        \n        // Using lambda with forEach\n        names.forEach(name -> System.out.println(\"Hello, \" + name));\n        \n        // Using lambda with filter and forEach\n        names.stream()\n             .filter(name -> name.length() > 4)\n             .forEach(name -> System.out.println(\"Long name: \" + name));\n        \n        // Lambda with Comparator\n        List<Person> people = Arrays.asList(\n            new Person(\"Alice\", 25),\n            new Person(\"Bob\", 30),\n            new Person(\"Charlie\", 20),\n            new Person(\"David\", 35)\n        );\n        \n        // Sort by age using lambda\n        people.sort((p1, p2) -> Integer.compare(p1.getAge(), p2.getAge()));\n        System.out.println(\"Sorted by age: \" + people);\n        \n        // Sort by name using lambda\n        people.sort((p1, p2) -> p1.getName().compareTo(p2.getName()));\n        System.out.println(\"Sorted by name: \" + people);\n        \n        // Streams API\n        System.out.println(\"\\n=== Streams API ===\");\n        \n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n        \n        // Filter and map\n        List<Integer> evenSquares = numbers.stream()\n                                          .filter(n -> n % 2 == 0)\n                                          .map(n -> n * n)\n                                          .collect(Collectors.toList());\n        System.out.println(\"Even squares: \" + evenSquares);\n        \n        // Reduce operation\n        int sum = numbers.stream().reduce(0, Integer::sum);\n        System.out.println(\"Sum: \" + sum);\n        \n        // Collect to different collections\n        Set<String> nameSet = names.stream()\n                                   .filter(name -> name.startsWith(\"A\"))\n                                   .collect(Collectors.toSet());\n        System.out.println(\"Names starting with 'A': \" + nameSet);\n        \n        // Grouping and partitioning\n        Map<Integer, List<Person>> peopleByAge = people.stream()\n                                                       .collect(Collectors.groupingBy(Person::getAge));\n        System.out.println(\"People grouped by age: \" + peopleByAge);\n        \n        // Optional class\n        System.out.println(\"\\n=== Optional Class ===\");\n        \n        Optional<String> optionalName = Optional.of(\"John\");\n        Optional<String> emptyOptional = Optional.empty();\n        \n        // Using Optional methods\n        optionalName.ifPresent(name -> System.out.println(\"Name is: \" + name));\n        emptyOptional.ifPresent(name -> System.out.println(\"This won't print\"));\n        \n        String result1 = optionalName.orElse(\"Unknown\");\n        String result2 = emptyOptional.orElse(\"Unknown\");\n        System.out.println(\"Result 1: \" + result1);\n        System.out.println(\"Result 2: \" + result2);\n        \n        // Optional with map and filter\n        Optional<String> upperName = optionalName\n            .map(String::toUpperCase)\n            .filter(name -> name.length() > 3);\n        System.out.println(\"Filtered upper name: \" + upperName.orElse(\"None\"));\n        \n        // Method references\n        System.out.println(\"\\n=== Method References ===\");\n        \n        // Static method reference\n        List<String> upperNames = names.stream()\n                                       .map(String::toUpperCase)\n                                       .collect(Collectors.toList());\n        System.out.println(\"Upper names: \" + upperNames);\n        \n        // Instance method reference\n        List<Integer> nameLengths = names.stream()\n                                         .map(String::length)\n                                         .collect(Collectors.toList());\n        System.out.println(\"Name lengths: \" + nameLengths);\n        \n        // Constructor reference\n        List<Person> personList = names.stream()\n                                       .map(Person::new)\n                                       .collect(Collectors.toList());\n        System.out.println(\"Person list: \" + personList);\n        \n        // Date/Time API (Java 8)\n        System.out.println(\"\\n=== Date/Time API ===\");\n        \n        // Current date and time\n        LocalDate today = LocalDate.now();\n        LocalTime now = LocalTime.now();\n        LocalDateTime dateTime = LocalDateTime.now();\n        \n        System.out.println(\"Today: \" + today);\n        System.out.println(\"Now: \" + now);\n        System.out.println(\"DateTime: \" + dateTime);\n        \n        // Creating specific dates\n        LocalDate birthday = LocalDate.of(1990, Month.JUNE, 15);\n        LocalTime meetingTime = LocalTime.of(14, 30);\n        \n        System.out.println(\"Birthday: \" + birthday);\n        System.out.println(\"Meeting time: \" + meetingTime);\n        \n        // Date arithmetic\n        LocalDate tomorrow = today.plusDays(1);\n        LocalDate nextWeek = today.plusWeeks(1);\n        LocalDate nextMonth = today.plusMonths(1);\n        \n        System.out.println(\"Tomorrow: \" + tomorrow);\n        System.out.println(\"Next week: \" + nextWeek);\n        System.out.println(\"Next month: \" + nextMonth);\n        \n        // Duration and Period\n        Duration duration = Duration.between(now, now.plusHours(2));\n        Period period = Period.between(today, today.plusDays(30));\n        \n        System.out.println(\"Duration: \" + duration);\n        System.out.println(\"Period: \" + period);\n        \n        // Formatting dates\n        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\n        String formattedDateTime = dateTime.format(formatter);\n        System.out.println(\"Formatted: \" + formattedDateTime);\n        \n        // Default methods in interfaces\n        System.out.println(\"\\n=== Default Methods ===\");\n        \n        Vehicle car = new Car();\n        car.start();\n        car.honk(); // Default method\n        car.stop();\n        \n        // Try-with-resources with multiple resources\n        System.out.println(\"\\n=== Try-with-resources ===\");\n        try (ResourceManager resource1 = new ResourceManager(\"Resource 1\");\n             ResourceManager resource2 = new ResourceManager(\"Resource 2\")) {\n            resource1.use();\n            resource2.use();\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}\n\n// Person class with constructor for method reference\nclass Person {\n    private String name;\n    private int age;\n    \n    public Person(String name) {\n        this.name = name;\n        this.age = 0;\n    }\n    \n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    public String getName() { return name; }\n    public int getAge() { return age; }\n    \n    @Override\n    public String toString() {\n        return name + \"(\" + age + \")\";\n    }\n}\n\n// Interface with default method\ninterface Vehicle {\n    void start();\n    void stop();\n    \n    default void honk() {\n        System.out.println(\"Honk! Honk!\");\n    }\n}\n\nclass Car implements Vehicle {\n    @Override\n    public void start() {\n        System.out.println(\"Car starting...\");\n    }\n    \n    @Override\n    public void stop() {\n        System.out.println(\"Car stopping...\");\n    }\n}\n\n// Resource manager for try-with-resources\nclass ResourceManager implements AutoCloseable {\n    private String name;\n    \n    public ResourceManager(String name) {\n        this.name = name;\n    }\n    \n    public void use() {\n        System.out.println(\"Using \" + name);\n    }\n    \n    @Override\n    public void close() {\n        System.out.println(\"Closing \" + name);\n    }\n}"
            },
            {
              "type": "text",
              "content": "Lambda expressions provide concise functional programming. Streams API enables declarative data processing. Optional helps handle null values safely. Modern Date/Time API is more robust than legacy classes."
            }
          ]
        }
      }
    ],
    "quiz": {
      "questions": [
        {
          "question": "What is the main benefit of using generics?",
          "options": [
            "They make code run faster",
            "They provide compile-time type safety",
            "They reduce memory usage",
            "They make code more readable"
          ],
          "correct": 1,
          "explanation": "Generics provide compile-time type safety, eliminating the need for casting and preventing ClassCastException at runtime."
        },
        {
          "question": "What does the @Override annotation do?",
          "options": [
            "It makes a method run faster",
            "It indicates that a method overrides a superclass method",
            "It prevents a method from being overridden",
            "It makes a method static"
          ],
          "correct": 1,
          "explanation": "The @Override annotation indicates that a method is intended to override a method in a superclass, helping catch errors at compile time."
        },
        {
          "question": "What is reflection used for?",
          "options": [
            "To make code run faster",
            "To examine and modify class behavior at runtime",
            "To create new programming languages",
            "To optimize memory usage"
          ],
          "correct": 1,
          "explanation": "Reflection allows examining and modifying the behavior of classes, methods, and fields at runtime, though it should be used carefully due to performance implications."
        },
        {
          "question": "What is a lambda expression?",
          "options": [
            "A way to create anonymous functions",
            "A type of variable",
            "A method name",
            "A class name"
          ],
          "correct": 0,
          "explanation": "Lambda expressions provide a way to create anonymous functions, making code more concise and enabling functional programming in Java."
        },
        {
          "question": "What is the purpose of the Optional class?",
          "options": [
            "To make code run faster",
            "To handle null values safely",
            "To create new objects",
            "To sort collections"
          ],
          "correct": 1,
          "explanation": "The Optional class provides a way to handle null values safely, encouraging explicit null checking and reducing NullPointerException."
        }
      ]
    }
  }
} 